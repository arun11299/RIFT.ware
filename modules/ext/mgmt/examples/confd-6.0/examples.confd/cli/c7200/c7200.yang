module c7200 {
    namespace 'urn:c7200';
    prefix c;

    import tailf-common {
        prefix tailf;
    }
    import ietf-inet-types {
        prefix inet;
    }

    typedef dscp-type {
        type union {
            type uint16 {
                range "0..63";
                tailf:info "<0-63>;;Differentiated services codepoint value";
            }
            type enumeration {
                enum af11 {
                    tailf:info "Match packets with AF11 dscp (001010)";
                }
                enum af12 {
                    tailf:info "Match packets with AF12 dscp (001100)";
                }
                enum af13 {
                    tailf:info "Match packets with AF13 dscp (001110)";
                }
                enum af21 {
                    tailf:info "Match packets with AF21 dscp (010010)";
                }
                enum af22 {
                    tailf:info "Match packets with AF22 dscp (010100)";
                }
                enum af23 {
                    tailf:info "Match packets with AF23 dscp (010110)";
                }
                enum af31 {
                    tailf:info "Match packets with AF31 dscp (011010)";
                }
                enum af32 {
                    tailf:info "Match packets with AF32 dscp (011100)";
                }
                enum af33 {
                    tailf:info "Match packets with AF33 dscp (011110)";
                }
                enum af41 {
                    tailf:info "Match packets with AF41 dscp (100010)";
                }
                enum af42 {
                    tailf:info "Match packets with AF42 dscp (100100)";
                }
                enum af43 {
                    tailf:info "Match packets with AF43 dscp (100110)";
                }
                enum cs1 {
                    tailf:info "Match packets with CS1(precedence 1) dscp"+
                        " (001000)";
                }
                enum cs2 {
                    tailf:info "Match packets with CS2(precedence 2) dscp"+
                        " (010000)";
                }
                enum cs3 {
                    tailf:info "Match packets with CS3(precedence 3) dscp"+
                        " (011000)";
                }
                enum cs4 {
                    tailf:info "Match packets with CS4(precedence 4) dscp"+
                        " (100000)";
                }
                enum cs5 {
                    tailf:info "Match packets with CS5(precedence 5) dscp"+
                        " (101000)";
                }
                enum cs6 {
                    tailf:info "Match packets with CS6(precedence 6) dscp"+
                        " (110000)";
                }
                enum cs7 {
                    tailf:info "Match packets with CS7(precedence 7) dscp"+
                        " (111000)";
                }
                enum "default" {
                    tailf:code-name "dscp_default";
                    tailf:info "Match packets with default dscp (000000)";
                }
                enum ef {
                    tailf:info "Match packets with EF dscp (101110)";
                }
            }
        }
    }

    typedef precedence-type {
        type union {
            type uint16 {
                range "0..7";
                tailf:info "<0-7>;;Precedence value";
            }
            type enumeration {
                enum critical {
                    tailf:info "Set packets with critical precedence (5)";
                }
                enum flash {
                    tailf:info "Set packets with flash precedence (3)";
                }
                enum flash-override {
                    tailf:info "Set packets with flash override precedence (4)";
                }
                enum immediate {
                    tailf:info "Set packets with immediate precedence (2)";
                }
                enum internet {
                    tailf:code-name "prec_internet";
                    tailf:info "Set packets with internetwork control "+
                        "precedence (6)";
                }
                enum network {
                    tailf:info "Set packets with network control precedence "+
                        "(7)";
                }
                enum priority {
                    tailf:code-name "prec_priority";
                    tailf:info "Set packets with priority precedence (1)";
                }
                enum routine {
                    tailf:info "Set packets with routine precedence (0)";
                }
            }
        }
    }

    typedef police-action-type {
        type enumeration {
            enum drop {
                tailf:code-name "police_drop";
                tailf:info "drop packet";
            }
            enum set-clp-transmit {
                tailf:info "set atm clp and send it";
            }
            enum set-discard-class-transmit {
                tailf:info "set discard-class and send it";
            }
            enum set-dscp-transmit {
                tailf:info "set dscp and send it";
            }
            enum set-frde-transmit {
                tailf:info "set FR DE and send it";
            }
            enum set-mpls-exp-imposition-transmit {
                tailf:info "set exp at tag imposition and send it";
            }
            enum set-mpls-exp-topmost-transmit {
                tailf:info "set exp on topmost label and send it";
            }
            enum set-prec-transmit {
                tailf:info "rewrite packet precedence and send it";
            }
            enum set-qos-transmit {
                tailf:info "set qos-group and send it";
            }
            enum transmit {
                tailf:code-name "police_transmit";
                tailf:info "transmit packet";
            }
        }
    }

    grouping match-grouping {
        container access-group {
            tailf:info "Access group";
            leaf index {
                tailf:cli-drop-node-name;
                type uint32 {
                    range "1..2699" {
                        tailf:info "<1-2699>;;Access list index";
                    }
                }
            }
            leaf-list name {
                tailf:info "Named Access List";
                tailf:cli-list-syntax;
                type string {
                    tailf:info "WORD;;Access List name";
                }
            }
        }
        leaf any {
            tailf:info "Any packets";
            type empty;
        }
        leaf-list class-map {
            tailf:info "Class map";
            tailf:cli-list-syntax;
            type leafref {
                path "/class-map/name";
                // tailf:info "WORD;;Match class-map name";
            }
        }
        leaf-list cos {
            tailf:info "IEEE 802.1Q/ISL class of service/user priority values";
            tailf:cli-flat-list-syntax;
            type uint16 {
                range "0..7";
                tailf:info "<0-7>;;Enter up to 4 class-of-service values "+
                    "separated by white-spaces";
            }
        }
        container destination-address {
            tailf:info "Destination address";
            leaf-list mac {
                tailf:info "MAC address";
                tailf:cli-list-syntax;
                type string {
                    tailf:info "H.H.H;;MAC address";
                }
            }
        }
        leaf-list discard-class {
            tailf:info "Discard behavior identifier";
            tailf:cli-list-syntax;
            type uint16 {
                range "0..7";
                tailf:info "<0-7>;;Discard Class value";
            }
        }
        leaf-list dscp {
            tailf:info "Match DSCP in IP(v4) and IPv6 packets";
            tailf:cli-list-syntax;
            type dscp-type;
        }
        leaf fr-de {
            tailf:info "Match on Frame-relay DE bit";
            type empty;
        }
        leaf-list fr-dlci {
            tailf:info "Match on fr-dlci";
            tailf:cli-list-syntax;
            type uint16 {
                range "16..1007";
                tailf:info "<16-1007>;;frame-relay dlci number";
            }
        }
        leaf-list input-interface {
            tailf:info "Select an input interface to match";
            tailf:cli-list-syntax;
            type string;

            // leaf Async {
            //     type uint16 {
            //         range "1..1";
            //         tailf:info "<1-1>;;Async interface number";
            //     }
            // }
            // leaf BVI {
            //     // FIXME: should be leaf ref
            //     type uint16 {
            //         range "1..255";
            //         tailf:info "<1-255>;;BVI interface number";
            //     }
            // }
            // leaf CDMA-Ix {
            //     type uint16 {
            //         range "1..1";
            //         tailf:info "<1-1>;;CDMA-Ix interface number";
            //     }
            // }
            // leaf CTunnel {
            //
            // }
        }
        container ip {
            tailf:info "IP specific values";
            leaf-list dscp {
                tailf:info "Match IP DSCP (DiffServ CodePoints)";
                tailf:cli-list-syntax;
                type dscp-type;
            }
            leaf-list precedence {
                tailf:info "Match IP precedence";
                type precedence-type;
            }
            list rtp {
                tailf:info "Match RTP port nos";
                key "port1 port2";
                leaf port1 {
                    type uint16 {
                        range "2000..65535";
                        tailf:info "<2000-65535>;;Lower bound of UDP "+
                            "destination port";
                    }
                }
                leaf port2 {
                    type uint16 {
                        range "0..16383";
                        tailf:info "<0-16383>;;Range of UDP ports";
                    }
                }
            }
        }
        container mpls {
            tailf:info "Multi Protocol Label Switching specific values";
            container experimental {
                tailf:info "Match MPLS experimental";
                leaf-list topmost {
                    tailf:info "Match MPLS experimental value on topmost label";
                    tailf:cli-flat-list-syntax;
                    type uint16 {
                        range "0..7";
                        tailf:info "<0-7>;;Enter up to 8 experimental values "+
                            "separated by white-spaces";
                    }
                }
            }
        }
        container packet {
            tailf:info "Layer 3 Packet length";
            container "length" {
                tailf:info "Layer 3 Packet length";
                leaf max {
                    tailf:info "Maximum length of packet";
                    type uint16 {
                        range "1..2000";
                        tailf:info "<1-2000>;;Packet length in bytes";
                    }
                }
                leaf min {
                    tailf:info "Minimum length of packet";
                    type uint16 {
                        range "1..2000";
                        tailf:info "<1-2000>;;Packet length in bytes";
                    }
                }
            }
        }
        leaf-list precedence {
            tailf:info "Match Precedence in IP(v4) and IPv6 packets";
            type precedence-type;
        }
        container protocol {
            tailf:info "Protocol";
            leaf aarp {
                type empty;
                tailf:info "AppleTalk ARP";
            }
            leaf appletalk {
                type empty;
                tailf:info "AppleTalk";
            }
            leaf arp {
                type empty;
                tailf:info "IP ARP";
            }
            leaf bgp {
                type empty;
                tailf:info "Border Gateway Protocol";
            }
            leaf bridge {
                type empty;
                tailf:info "Bridging";
            }
            leaf bstun {
                type empty;
                tailf:info "Block Serial Tunnel";
            }
            leaf cdp {
                type empty;
                tailf:info "Cisco Discovery Protocol";
            }
            container citrix {
                tailf:info "Citrix Systems ICA protocol";
                presence "enable citrix system protocol matching";
                leaf ica-tag {
                    tailf:info "Citrix ICA tag 0-high 1-medium 2-low "+
                        "3-background";
                    type string {
                        tailf:info "WORD;;Enter a string as the sub-protocol "+
                            "parameter";
                    }
                }
            }
            leaf clns {
                type empty;
                tailf:info "ISO CLNS";
            }
            leaf clns_es {
                type empty;
                tailf:info "ISO CLNS End System";
            }
            leaf clns_is {
                type empty;
                tailf:info "ISO CLNS Intermediate System";
            }
            leaf cmns {
                type empty;
                tailf:info "ISO CMNS";
            }
            leaf compressedtcp {
                type empty;
                tailf:info "Compressed TCP (VJ";
            }
            leaf cuseeme {
                type empty;
                tailf:info "CU-SeeMe desktop video conference";
            }
            leaf decnet {
                type empty;
                tailf:info "DECnet";
            }
            leaf decnet_node {
                type empty;
                tailf:info "DECnet Node";
            }
            leaf decnet_router-l1 {
                type empty;
                tailf:info "DECnet Router L1";
            }
            leaf decnet_router-l2 {
                type empty;
                tailf:info "DECnet Router L2";
            }
            leaf dhcp {
                type empty;
                tailf:info "Dynamic Host Configuration";
            }
            leaf dlsw {
                type empty;
                tailf:info "Data Link Switching (Direct encapsulation only";
            }
            leaf dns {
                type empty;
                tailf:info "Domain Name Server lookup";
            }
            leaf edonkey {
                type empty;
                tailf:info "eDonkey";
            }
            leaf egp {
                type empty;
                tailf:info "Exterior Gateway Protocol";
            }
            leaf eigrp {
                type empty;
                tailf:info "Enhanced Interior Gateway Routing Protocol";
            }
            leaf exchange {
                type empty;
                tailf:info "MS-RPC for Exchange";
            }
            container fasttrack {
                tailf:info "FastTrack Traffic - KaZaA, Morpheus, Grokster";
                presence "enable fasttrack matching";
                leaf file-transfer {
                    tailf:info "File transfer stream";
                    type string {
                        tailf:info "WORD;;Enter a string as the sub-protocol "+
                            "parameter";
                    }
                }
            }
            leaf finger {
                type empty;
                tailf:info "Finger";
            }
            leaf ftp {
                type empty;
                tailf:info "File Transfer Protocol";
            }
            container gnutella {
                tailf:info "Gnutella Version2 Traffic - BearShare, Shareeza, "+
                    "Morpheus";
                presence "enable gnutella matching";
                leaf file-transfer {
                    tailf:info "File transfer stream";
                    type string {
                        tailf:info "WORD;;Enter a string as the sub-protocol "+
                            "parameter";
                    }
                }
            }
            leaf gopher {
                type empty;
                tailf:info "Gopher";
            }
            leaf gre {
                type empty;
                tailf:info "Generic Routing Encapsulation";
            }
            leaf h323 {
                type empty;
                tailf:info "H323 Protocol";
            }
            container http {
                tailf:info "World Wide Web traffic";
                presence "enable http traffic matching";
                leaf c-header-field {
                    tailf:info "Client general Header Field";
                    type string {
                        tailf:info "WORD;;Enter a string as the sub-protocol "+
                            "parameter";
                    }
                }
                leaf host {
                    tailf:info "Server Host Name";
                    type string {
                        tailf:info "WORD;;Enter a string as the sub-protocol "+
                            "parameter";
                    }
                }
                leaf mime {
                    tailf:info "Match MIME Type";
                    type string {
                        tailf:info "WORD;;Enter a string as the sub-protocol "+
                            "parameter";
                    }
                }
                leaf s-header-field {
                    tailf:info "Server general Header Field";
                    type string {
                        tailf:info "WORD;;Enter a string as the sub-protocol "+
                            "parameter";
                    }
                }
                leaf url {
                    tailf:info "Match URL String";
                    type string {
                        tailf:info "WORD;;Enter a string as the sub-protocol "+
                            "parameter";
                    }
                }
            }
            leaf icmp {
                type empty;
                tailf:info "Internet Control Message";
            }
            leaf imap {
                type empty;
                tailf:info "Internet Message Access Protocol";
            }
            leaf ip {
                type empty;
                tailf:info "IP";
            }
            leaf ipinip {
                type empty;
                tailf:info "IP in IP (encapsulation";
            }
            leaf ipsec {
                type empty;
                tailf:info "IP Security Protocol (ESP/AH";
            }
            leaf ipv6 {
                type empty;
                tailf:info "IPV6";
            }
            leaf ipx {
                type empty;
                tailf:info "Novell IPX";
            }
            leaf irc {
                type empty;
                tailf:info "Internet Relay Chat";
            }
            container kazaa2 {
                tailf:info "Kazaa Version 2";
                presence "enable kazaa version 2 matching";
                leaf file-transfer {
                    tailf:info "File transfer stream";
                    type string {
                        tailf:info "WORD;;Enter a string as the sub-protocol "+
                            "parameter";
                    }
                }
            }
            leaf kerberos {
                type empty;
                tailf:info "Kerberos";
            }
            leaf l2tp {
                type empty;
                tailf:info "L2F/L2TP tunnel";
            }
            leaf ldap {
                type empty;
                tailf:info "Lightweight Directory Access Protocol";
            }
            leaf llc2 {
                type empty;
                tailf:info "llc2";
            }
            leaf mgcp {
                type empty;
                tailf:info "Media Gateway Control Protocol";
            }
            container napster {
                tailf:info "Napster Traffic";
                presence "enable napster matching";
                leaf non-std {
                    tailf:info "Non-standard port advertizements";
                    type empty;
                }
            }
            leaf netbios {
                type empty;
                tailf:info "NetBIOS";
            }
            leaf netshow {
                type empty;
                tailf:info "Microsoft Netshow";
            }
            leaf nfs {
                type empty;
                tailf:info "Network File System";
            }
            leaf nntp {
                type empty;
                tailf:info "Network News Transfer Protocol";
            }
            leaf notes {
                type empty;
                tailf:info "Lotus Notes(R";
            }
            leaf novadigm {
                type empty;
                tailf:info "Novadigm EDM";
            }
            leaf ntp {
                type empty;
                tailf:info "Network Time Protocol";
            }
            leaf ospf {
                type empty;
                tailf:info "Open Shortest Path First";
            }
            leaf pad {
                type empty;
                tailf:info "PAD links";
            }
            leaf pcanywhere {
                type empty;
                tailf:info "Symantec pcANYWHERE";
            }
            leaf pop3 {
                type empty;
                tailf:info "Post Office Protocol";
            }
            leaf pppoe {
                type empty;
                tailf:info "PPP over Ethernet";
            }
            leaf pptp {
                type empty;
                tailf:info "Point-to-Point Tunneling Protocol";
            }
            leaf printer {
                type empty;
                tailf:info "print spooler/lpd";
            }
            leaf qllc {
                type empty;
                tailf:info "qllc protocol";
            }
            leaf rcmd {
                type empty;
                tailf:info "BSD r-commands (rsh, rlogin, rexec";
            }
            leaf rip {
                type empty;
                tailf:info "Routing Information Protocol";
            }
            leaf rsrb {
                type empty;
                tailf:info "Remote Source-Route Bridging";
            }
            leaf rsvp {
                type empty;
                tailf:info "Resource Reservation Protocol";
            }
            leaf rtcp {
                type empty;
                tailf:info "Real Time Control Protocol";
            }
            container rtp {
                tailf:info "Real Time Protocol";
                presence "enable rtp matching";
                leaf audio {
                    tailf:info "Match voice packets";
                    type empty;
                }
                leaf payload-type {
                    tailf:info "Match an explicit PT";
                    type string {
                        tailf:info "WORD;;Enter a string as the sub-protocol "+
                            "parameter";
                    }
                }
                leaf video {
                    tailf:info "Match video packets";
                    type empty;
                }
            }
            leaf rtsp {
                type empty;
                tailf:info "Real Time Streaming Protocol";
            }
            leaf secure-ftp {
                type empty;
                tailf:info "FTP over TLS/SSL";
            }
            leaf secure-http {
                type empty;
                tailf:info "Secured HTTP";
            }
            leaf secure-imap {
                type empty;
                tailf:info "Internet Message Access Protocol over TLS/SSL";
            }
            leaf secure-irc {
                type empty;
                tailf:info "Internet Relay Chat over TLS/SSL";
            }
            leaf secure-ldap {
                type empty;
                tailf:info "Lightweight Directory Access Protocol over TLS/SSL";
            }
            leaf secure-nntp {
                type empty;
                tailf:info "Network News Transfer Protocol over TLS/SSL";
            }
            leaf secure-pop3 {
                type empty;
                tailf:info "Post Office Protocol over TLS/SSL";
            }
            leaf secure-telnet {
                type empty;
                tailf:info "Telnet over TLS/SSL";
            }
            leaf sip {
                type empty;
                tailf:info "Session Initiation Protocol";
            }
            leaf skinny {
                type empty;
                tailf:info "Skinny Protocol";
            }
            leaf smtp {
                type empty;
                tailf:info "Simple Mail Transfer Protocol";
            }
            leaf snapshot {
                type empty;
                tailf:info "Snapshot routing support";
            }
            leaf snmp {
                type empty;
                tailf:info "Simple Network Management Protocol";
            }
            leaf socks {
                type empty;
                tailf:info "SOCKS";
            }
            leaf sqlnet {
                type empty;
                tailf:info "SQL*NET for Oracle";
            }
            leaf sqlserver {
                type empty;
                tailf:info "MS SQL Server";
            }
            leaf ssh {
                type empty;
                tailf:info "Secured Shell";
            }
            leaf streamwork {
                type empty;
                tailf:info "Xing Technology StreamWorks player";
            }
            leaf stun {
                type empty;
                tailf:info "Serial Tunnel";
            }
            leaf sunrpc {
                type empty;
                tailf:info "Sun RPC";
            }
            leaf syslog {
                type empty;
                tailf:info "System Logging Utility";
            }
            leaf telnet {
                type empty;
                tailf:info "Telnet";
            }
            leaf tftp {
                type empty;
                tailf:info "Trivial File Transfer Protocol";
            }
            leaf vdolive {
                type empty;
                tailf:info "VDOLive streaming video";
            }
            leaf vofr {
                type empty;
                tailf:info "voice over Frame Relay packets";
            }
            leaf winmx {
                type empty;
                tailf:info "WinMx file-sharing application";
            }
            leaf xwindows {
                type empty;
                tailf:info "X-Windows remote access";
            }
        }
        leaf-list qos-group {
            tailf:info "Qos-group";
            tailf:cli-list-syntax;
            type uint16 {
                range "0..99";
                tailf:info "<0-99>;;Qos Group value";
            }
        }
        container source-address {
            tailf:info "Source address";
            leaf-list mac {
                tailf:info "MAC address";
                tailf:cli-list-syntax;
                type string {
                    tailf:info "H.H.H;;MAC address";
                }
            }
        }
    }

    list class-map {
        tailf:info "Configure QoS Class Map";
        tailf:cli-mode-name "config-cmap";
        key "name";
        leaf name {
            type string {
                tailf:info "WORD;;class-map name";
            }
        }
        leaf prematch {
            tailf:cli-prefix-key;
            tailf:cli-drop-node-name;
            type enumeration {
                enum match-all {
                    tailf:info "Logical-AND all matching statements under "+
                        "this classmap";
                }
                enum match-any {
                    tailf:info "Logical-OR all matching statements under this "+
                        "classmap";
                }
            }
            default match-all;
        }
        leaf description {
            tailf:info "Class-Map description";
            tailf:cli-multi-value;
            type string {
                tailf:info "LINE;;Description of this class-map (up to 200 "+
                    "characters)";
            }
        }
        container match {
            tailf:info "classification criteria";
            uses match-grouping;
            container not {
                tailf:info "Negate this match result";
                uses match-grouping;
            }
        }
        // rename is action and not needed
    }

    typedef class-name-type {
        type union {
            type string {
                tailf:info "WORD;;class-map name";
            }
            type enumeration {
                enum class-default {
                    tailf:info "System default class matching otherwise "+
                        "unclassified packet";
                }
            }
        }
    }

    typedef precedence-type2 {
        type union {
            type uint16 {
                range "0..7";
                tailf:info "<0-7>;;IP precedence";
            }
            type enumeration {
                enum rsvp {
                    tailf:code-name "prec_rsvp";
                    tailf:info "rsvp traffic";
                }
            }
        }
    }

    typedef mdt-data-list-type {
        type union {
            type uint16 {
                range "100..199";
                tailf:info "<100-199>;;Access-list number";
            }
            type uint16 {
                range "2000..2699";
                tailf:info "<2000-2699>;;Access list number (expanded range)";
            }
            type string {
                tailf:info "WORD;;IP Named Extended Access list";
                pattern '[a-fA-F].*';
            }
        }
    }

    typedef distribute-list-type {
        type union {
            type uint16 {
                range "100..199";
                tailf:info "<100-199>;;IP access-list number";
            }
            type uint16 {
                range "2000..2699";
                tailf:info "<2000-2699>;;IP expanded access list number";
            }
            type string {
                tailf:info "WORD;;Access-list name";
                pattern '[a-zA-Z].*';
            }
        }
    }

    typedef distribute-list-type2 {
        type union {
            type uint16 {
                range "1..199";
                tailf:info "<1-199>;;IP access list number";
            }
            type uint16 {
                range "1300..2699";
                tailf:info "<1300-2699>;;IP access list number (expanded "
                    +"range)";
            }
            type string {
                tailf:info "WORD;;Access-list name";
                pattern '[a-zA-Z].*';
            }
        }
    }

    typedef rd-type {
        type string {
            tailf:info "ASN:nn or IP-address:nn;;VPN Route Distinguisher";
            pattern '(\d*(.\d*)*)?:\d\d?';
        }
    }

    typedef vpn-id-type {
        type string {
            tailf:info "OUI:VPN-Index;;, format (hex) <3 bytes OUI:4 bytes "
                +"VPN_Index>";
            pattern '[0-9a-fA-F][0-9a-fA-F]?[0-9a-fA-F]?:[0-9a-fA-F][0-9a-fA-F]?[0-9a-fA-F]?[0-9a-fA-F]?';
        }
    }

    grouping random-detect-grouping {
        leaf min-threshold {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
                range "1..4096";
                tailf:info "<1-4096>;;minimum threshold (number of packets)";
            }
        }
        leaf max-threshold {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
                range "1..4096";
                tailf:info "<1-4096>;;maximum threshold (number of packets)";
            }
        }
        leaf denominator {
            tailf:cli-drop-node-name;
            type uint32 {
                range "1..65535";
                tailf:info "<1-65535>;;mark probability denominator";
            }
        }
    }


    grouping max-path-grouping {
        container max-path {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
            }
            leaf max {
                tailf:cli-drop-node-name;
                type uint16 {
                    range "1..16";
                    tailf:info "<1-16>;;Number of paths";
                }
                default "1";
            }
            leaf import {
                tailf:info "Maximum import paths";
                type uint16 {
                    range "1..16";
                    tailf:info "<1-16>;;Number of import paths";
                }
            }
        }
    }

    typedef neighbor-id-type {
        type union {
            type inet:ipv4-address {
                tailf:info "A.B.C.D;;Neighbor addres";
            }
            type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;Neighbor IPv6 address";
            }
            type string {
                tailf:info "WORD;;Neighbor tag";
            }
        }
    }

    typedef access-list-type {
        type union {
            type uint16 {
                range "1..199";
                tailf:info "<1-199>;;Access list";
            }
            type uint16 {
                range "1300..2699";
                tailf:info "<1300-2699>;;Access list (expanded range)";
            }
        }
    }

    grouping metric-route-map-grouping {
        leaf metric {
            tailf:cli-break-sequence-commands;
            tailf:info "Metric for redistributed routes";
            type uint32 {
                range "0..4294967295";
                tailf:info "<0-4294967295>;;Default metric";
            }
        }
        leaf route-map {
            tailf:info "Route map reference";
            type string {
                tailf:info "WORD;;Pointer to route-map entries";
            }
        }
    }

    grouping route-map-metric-grouping {
        leaf route-map {
            tailf:info "Route map reference";
            type string {
                tailf:info "WORD;;Pointer to route-map entries";
            }
        }
        leaf metric {
            tailf:info "Metric for redistributed routes";
            type uint32 {
                range "0..4294967295";
                tailf:info "<0-4294967295>;;Default metric";
            }
        }
    }

    grouping redistribute-isis-grouping {
        choice osi-ip-choice {
            leaf ip {
                tailf:info "Redistribution of IP dynamic routes";
                type empty;
            }
            leaf clns {
                tailf:info "Redistribution of OSI dynamic routes";
                type empty;
            }
        }
        leaf routes {
            tailf:cli-drop-node-name;
            type enumeration {
                enum level-1 {
                    tailf:info "IS-IS level-1 routes only";
                }
                enum level-2 {
                    tailf:info "IS-IS level-2 routes only";
                }
                enum level-1-2 {
                    tailf:info "IS-IS level-1 and level-2 routes";
                }
            }
        }
        uses metric-route-map-grouping;
    }

    grouping address-family-grouping {
        container aggregate-address {
            tailf:info "Configure BGP aggregate entries";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
                tailf:cli-reset-all-siblings;
            }
            leaf address {
                tailf:cli-drop-node-name;
                type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Aggregate address";
                }
            }
            leaf mask {
                tailf:cli-drop-node-name;
                type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Aggregate mask";
                }
            }
            leaf advertise-map {
                tailf:cli-break-sequence-commands;
                tailf:info "Set condition to advertise attribute";
                type string {
                    tailf:info "WORD;;Route map to control attribute "
                        +"advertisement";
                }
            }
            leaf as-set {
                tailf:info "Generate AS set path information";
                type empty;
            }
            leaf attribute-map {
                type string {
                    tailf:info "WORD;;Route map for parameter control";
                }
            }
            leaf route-map {
                type string {
                    tailf:info "WORD;;Route map for parameter control";
                }
            }
            leaf summary-only {
                tailf:info "Filter more specific routes from updates";
                type empty;
            }
            leaf suppress-map {
                tailf:info "Conditionally filter more specific routes from "
                    +"updates";
                type string {
                    tailf:info "WORD;;Route map for suppression";
                }
            }
        }
        container bgp {
            tailf:info "BGP specific commands";
            tailf:cli-incomplete-command;

            leaf always-compare-med {
                tailf:cli-full-command;
                tailf:info "Allow comparing MED from different neighbors";
                type empty;
            }

            container bestpath {
                tailf:info "Change the default bestpath selection";
                leaf compare-routerid {
                    tailf:cli-full-command;
                    tailf:info "Compare router-id for identical EBGP paths";
                    type empty;
                }
                container cost-community {
                    tailf:info "cost community";
                    leaf ignore {
                        tailf:info "Ignore cost communities in bestpath "
                            +"selection";
                        type empty;
                    }
                }
                container med {
                    tailf:info "MED attribute";
                    choice med-choice {
                        container confed {
                            tailf:info "Compare MED among confederation paths";
                            presence "Compare MED among confederation paths";
                            leaf missing-at-worst {
                                tailf:info "Treat missing MED as the least "
                                    +"preferred one";
                                type empty;
                            }
                        }
                        leaf missing-at-worst {
                            tailf:info "Treat missing MED as the least "
                                +"preferred one";
                            type empty;
                        }
                    }
                }
            }

            container client-to-client {
                tailf:info "Configure client to client route reflection";
                leaf reflection {
                    tailf:info "reflection of routes allowed";
                    type empty;
                }
            }

            leaf cluster-id {
                tailf:cli-full-command;
                type union {
                    type uint32 {
                        range "1..4294967295";
                        tailf:info "<1-4294967295>;;Route-Reflector Cluster-id "
                            +"as 32 bit quantity";
                    }
                    type inet:ipv4-address {
                        tailf:info "A.B.C.D;;Route-Reflector Cluster-id in IP "
                            +"address format";
                    }
                }
            }

            container confederation {
                tailf:info "AS confederation parameters";
                leaf identifier {
                    tailf:cli-full-command;
                    tailf:info "as number";
                    type uint16 {
                        range "1..65535";
                        tailf:info "<1-65535>;;Set routing domain "
                            +"confederation AS";
                    }
                }
                container peers {
                    tailf:info "Peer ASs in BGP confederation";
                    presence "Peer ASs in BGP confederation";
                    leaf-list peers-as {
                        tailf:cli-drop-node-name;
                        tailf:cli-flat-list-syntax;
                        type uint16 {
                            range "1..65535";
                            tailf:info "AS number";
                        }
                    }
                }
            }

            container dampening {
                tailf:info "Enable route-flap dampening";
                presence "enable bgp route-flap dampening";
                choice dampening-choice {
                    leaf route-map {
                        tailf:info "Route-map to specify criteria for "
                            +"dampening";
                        type string {
                            tailf:info "WORD;;route-map name";
                        }
                    }
                    container dampen {
                        tailf:cli-drop-node-name;
                        tailf:cli-compact-syntax;
                        tailf:cli-sequence-commands;
                        leaf half-life-time {
                            tailf:cli-drop-node-name;
                            tailf:cli-incomplete-command;
                            type uint8 {
                                range "1 .. 45";
                                tailf:info "<1-45>;;Half-life time for the "
                                    +"penalty";
                            }
                        }
                        leaf reuse-time {
                            tailf:cli-drop-node-name;
                            tailf:cli-incomplete-command;
                            type uint16 {
                                range "1 .. 20000";
                                tailf:info "<1-20000>;;Value to start reusing "
                                    +"a route";
                            }
                        }
                        leaf suppress-time {
                            tailf:cli-drop-node-name;
                            tailf:cli-incomplete-command;
                            type uint16 {
                                range "1 .. 20000";
                                tailf:info "<1-20000>;;Value to start "
                                    +"suppressing a route";
                            }
                        }
                        leaf max-suppress-time {
                            tailf:cli-drop-node-name;
                            type uint8 {
                                range "1 .. 255";
                                tailf:info "<1-255>  Maximum duration to "
                                    +"suppress a stable route";
                            }
                        }
                    }
                }
            }
            container "default" {
                tailf:info "Configure BGP defaults";
                choice default-choice {
                    leaf ipv4-unicast {
                        tailf:info "Activate ipv4-unicast for a peer by "
                            +"default";
                        type empty;
                    }
                    leaf local-preference {
                        tailf:info "local preference (higher=more preferred)";
                        type uint32 {
                            range "1..4294967295";
                            tailf:info "<0-4294967295>;;Configure default "
                                +"local preference value";
                        }
                    }
                    leaf route-target {
                        tailf:info "Control behavior based on Route-Target "
                            +"attributes";
                        type enumeration {
                            enum filter {
                                tailf:info "Control automatic VPN Route-Target "
                                    +"filtering";
                            }
                        }
                    }
                }
            }
            leaf deterministic-med {
                tailf:cli-full-command;
                tailf:info "Pick the best-MED path among paths advertised from "
                    +"the neighboring AS";
                type empty;
            }
            leaf dmzlink-bw {
                tailf:cli-full-command;
                tailf:info "Use DMZ Link Bandwidth as weight for BGP "
                    +"multipaths";
                type empty;
            }
            leaf enforce-first-as {
                tailf:cli-full-command;
                tailf:info "Enforce the first AS for EBGP routes(default)";
                type empty;
            }
            leaf fast-external-fallover {
                tailf:cli-full-command;
                tailf:info "Immediately reset session if a link to a directly "
                    +"connected external peer goes down";
                type empty;
            }
            container graceful-restart {
                tailf:info "Graceful restart capability parameters";
                presence "Graceful restart capability parameters";
                leaf restart-time {
                    tailf:cli-full-command;
                    tailf:info "Set the max time needed to restart and come "
                        +"back up";
                    type uint16 {
                        range "1..3600";
                        tailf:info "<1-3600>;;Delay value (seconds)";
                    }
                }
                leaf stalepath-time {
                    tailf:info "Set the max time to hold onto restarting "
                        +"peer's stale paths";
                    type uint16 {
                        range "1..3600";
                        tailf:info "<1-3600>;;Delay value (seconds)";
                    }
                }
            }
            list inject-map {
                tailf:info "Routemap which specifies prefixes to inject";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                tailf:cli-incomplete-command;
                key name;
                leaf name {
                    type string {
                        tailf:info "WORD;;route-map name";
                    }
                }
                leaf exist-map {
                    tailf:info "Routemap which specifies exist condition";
                    type string {
                        tailf:info "WORD;;route-map name";
                    }
                }
                leaf copy-attributes {
                    tailf:info "Copy attributes from aggregate";
                    type empty;
                }
            }
            leaf log-neighbor-changes {
                tailf:info "Log neighbor up/down and reset reason";
                tailf:cli-full-command;
                type empty;
            }
            leaf maxas-limit {
                tailf:info "Allow AS-PATH attribute from any neighbor imposing "
                    +"a limit on number of ASes";
                tailf:cli-full-command;
                type uint16 {
                    range "1..2000";
                    tailf:info "<1-2000>;;Number of ASes in the AS-PATH "
                        +"attribute";
                }
            }
            container nexthop {
                tailf:info "Nexthop tracking commands";
                container trigger {
                    tailf:info "Nexthop triggering";
                    leaf delay {
                        tailf:cli-full-command;
                        tailf:info "Set the delay to tigger nexthop tracking";
                        type uint8 {
                            range "0..100";
                            tailf:info "<0-100>;;Delay value (seconds)";
                        }
                    }
                    leaf enable {
                        tailf:info "Enable nexthop tracking";
                        tailf:cli-full-command;
                        tailf:cli-boolean-no;
                        type boolean;
                        default "true";
                    }
                }
            }
            leaf redistribute-internal {
                tailf:info "Allow redistribution of iBGP into IGPs (dangerous)";
                tailf:cli-full-command;
                type empty;
            }
            container regexp {
                tailf:info "Select regular expression engine";
                leaf deterministic {
                    tailf:info "Enable bounded-execution-time regular "
                        +"expression engine";
                    type empty;
                }
            }
            leaf router-id {
                tailf:cli-full-command;
                tailf:info "Override configured router identifier (peers will "
                    +"reset)";
                type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Manually configured router identifier";
                }
            }
            leaf scan-time {
                tailf:cli-full-command;
                tailf:info "Configure background scanner interval";
                type uint8 {
                    range "5..60";
                    tailf:info "<5-60>;;Scanner interval (seconds)";
                }
            }

            leaf soft-reconfig-backup {
                tailf:info "Use soft-reconfiguration inbound only when route-"
                    +"refresh is not negotiated";
                tailf:cli-full-command;
                type empty;
            }
            leaf suppress-inactive {
                tailf:info "Suppress routes that are not in the routing table";
                tailf:cli-full-command;
                type empty;
            }
            leaf update-delay {
                tailf:cli-full-command;
                tailf:info "Set the max initial delay for sending update";
                type uint16 {
                    range "1..3600";
                    tailf:info "<1-3600>;;Delay value (seconds)";
                }
            }
        }
        container default-information {
            tailf:info "Control distribution of default information";
            leaf originate {
                tailf:info "Distribute a default route";
                type empty;
            }
        }
        leaf default-metric {
            tailf:info "Set metric of redistributed routes";
            tailf:cli-full-command;
            type uint32 {
                range "1..4294967295";
                tailf:info "<1-4294967295>;;Default metric";
            }
        }
        container distance {
            tailf:info "Define an administrative distance";
            container bgp {
                tailf:info "BGP distance";
                tailf:cli-sequence-commands;
                tailf:cli-compact-syntax;
                leaf extern-as {
                    tailf:cli-drop-node-name;
                    tailf:cli-incomplete-command;
                    type uint16 {
                        range "1..255";
                        tailf:info "<1-255>;;Distance for routes external to "
                            +"the AS";
                    }
                }
                leaf internal-as {
                    tailf:cli-drop-node-name;
                    tailf:cli-incomplete-command;
                    type uint16 {
                        range "1..255";
                        tailf:info "<1-255>;;Distance for routes internal to "
                            +"the AS";
                    }
                }
                leaf local {
                    tailf:cli-drop-node-name;
                    type uint16 {
                        range "1..255";
                        tailf:info "<1-255>;;Distance for local routes";
                    }
                }
            }
            list adm-distance {
                tailf:cli-drop-node-name;
                tailf:cli-suppress-mode;
                key "distance srcip wildbits";

                leaf distance {
                    type uint16 {
                        range "1..255";
                        tailf:info "<1-255>;;Administrative distance";
                    }
                }
                leaf srcip {
                    type inet:ipv4-address {
                        tailf:info "A.B.C.D;;IP Source address";
                    }
                }
                leaf wildbits {
                    type inet:ipv4-address {
                        tailf:info "A.B.C.D;;Wildcard bits";
                    }
                }
                leaf acl {
                    tailf:cli-drop-node-name;
                    type union {
                        type uint16 {
                            range "1..99" {
                                tailf:info "<1-99>;;IP Standard access list "
                                    +"number";
                            }
                        }
                        type uint16 {
                            range "1300..1999" {
                                tailf:info "<1300-1999>;;IP Standard expanded "
                                    +"access list number";
                            }
                        }
                        type string {
                            pattern '[a-zA-Z].*';
                            tailf:info "WORD;;Standard access-list name";
                        }
                    }
                }
            }
        }
        list distribute-list {
            tailf:info "Filter networks in routing updates";
            tailf:cli-compact-syntax;
            tailf:cli-suppress-mode;
            key id;
            leaf id {
                tailf:cli-incomplete-command;
                type distribute-list-type;
            }
            choice in-out-choice {
                container in {
                    presence "enable incoming routing updates";
                    tailf:info "Filter incoming routing updates";
                    leaf interface {
                        type string;
                    }
                    // FIXME: should be long list of
                    // Async              Async interface
                    // BVI                Bridge-Group Virtual Interface
                    // CDMA-Ix            CDMA Ix interface
                    // CTunnel            CTunnel interface
                    // Dialer             Dialer interface
                    // FastEthernet       FastEthernet IEEE 802.3
                    // Lex                Lex interface
                    // Loopback           Loopback interface
                    // MFR                Multilink Frame Relay bundle interface
                    // Multilink          Multilink-group interface
                    // Null               Null interface
                    // Port-channel       Ethernet Channel of interfaces
                    // Tunnel             Tunnel interface
                    // Vif                PGM Multicast Host interface
                    // Virtual-PPP        Virtual PPP interface
                    // Virtual-Template   Virtual Template interface
                    // Virtual-TokenRing  Virtual TokenRing
                    // XTagATM            Extended Tag ATM interface
                }
                container out {
                    presence "enable outgoing routing updates";
                    tailf:info "Filter outgoing routing updates";
                    leaf interface {
                        type string;
                    }
                    // FIXME: sholuld be list of
                    // Async              Async interface
                    // BVI                Bridge-Group Virtual Interface
                    // CDMA-Ix            CDMA Ix interface
                    // CTunnel            CTunnel interface
                    // Dialer             Dialer interface
                    // FastEthernet       FastEthernet IEEE 802.3
                    // Lex                Lex interface
                    // Loopback           Loopback interface
                    // MFR                Multilink Frame Relay bundle interface
                    // Multilink          Multilink-group interface
                    // Null               Null interface
                    // Port-channel       Ethernet Channel of interfaces
                    // Tunnel             Tunnel interface
                    // Vif                PGM Multicast Host interface
                    // Virtual-PPP        Virtual PPP interface
                    // Virtual-Template   Virtual Template interface
                    // Virtual-TokenRing  Virtual TokenRing
                    // XTagATM            Extended Tag ATM interface
                    // bgp                Border Gateway Protocol (BGP)
                    // connected          Connected
                    // eigrp              Enhanced Interior Gateway Routing Protocol (EIGRP)
                    // ospf               Open Shortest Path First (OSPF)
                    // rip                Routing Information Protocol (RIP)
                    // static             Static routes
                }
            }
        }
        container maximum-paths {
            tailf:info "Forward packets over multiple paths";
            choice max-path-choice {
                case eibgp-case {
                    container eibgp {
                        tailf:info "Both eBGP and iBGP paths as multipath";
                        uses max-path-grouping;
                    }
                }
                case ibgp-case {
                    container ibgp {
                        tailf:info "iBGP-multipath";
                        choice ibgp-choice {
                            case a {
                                container unequal-cost {
                                    tailf:info "Perform Un-Equal cost "
                                        +"multipath selection";
                                    uses max-path-grouping;
                                }
                            }
                            case b {
                                uses max-path-grouping;
                            }
                        }
                    }
                }
                case none-case {
                    uses max-path-grouping;
                }
                case import-case {
                    leaf import {
                        tailf:info "Maximum import paths";
                        type uint16 {
                            range "1..16";
                            tailf:info "<1-16>;;Number of import paths";
                        }
                    }
                }
            }
        }
        list neighbor {
            tailf:info "Specify a neighbor router";
            tailf:cli-suppress-mode;
            tailf:cli-incomplete-command;
            must "count(*) > 1" {
              tailf:dependency ".";
            }
            key "id";
            leaf id {
                type neighbor-id-type;
            }
            leaf remote-as {
                tailf:cli-full-command;
                tailf:info "Specify a BGP neighbor";
                type uint16 {
                    range "1..65535";
                    tailf:info "<1-65535>  AS of remote neighbor";
                }
            }
            leaf peer-group {
                tailf:info "Member of the peer-group";
                tailf:cli-full-command;
                type string {
                    tailf:info "WORD;;peer-group name";
                }
            }
            leaf activate {
                tailf:info "Enable the Address Family for this Neighbor";
                tailf:cli-full-command;
                must "(../remote-as or ../peer-group)";
                type empty;
            }
            leaf advertisement-interval {
                tailf:info "Minimum interval between sending BGP routing "
                    +"updates";
                tailf:cli-full-command;
                type uint16 {
                    range "0..600";
                    tailf:info "<0-600>;;time in seconds";
                }
            }
            container allowas-in {
                tailf:info "Accept as-path with my AS present in it";
                presence "accept as-paths";
                leaf as-number {
                    tailf:cli-drop-node-name;
                    type uint8 {
                        range "1..10";
                        tailf:info "<1-10>  Number of occurances of AS number";
                    }
                }
            }
            container capability {
                tailf:info "Advertise capability to the peer";
                container orf {
                    tailf:info "Advertise ORF capability to the peer";
                    leaf-list prefix-list {
                        tailf:cli-flat-list-syntax;
                        tailf:info "Advertise prefixlist ORF capability to "
                            +"this neighbor";
                        max-elements 1;
                        type enumeration {
                            enum both {
                                tailf:info "Capability to SEND and RECEIVE the "
                                    +"ORF to/from this neighbor";
                            }
                            enum receive {
                                tailf:info "Capability to RECEIVE the ORF from "
                                    +"this neighbor";
                            }
                            enum send {
                                tailf:info "Capability to SEND the ORF to this "
                                    +"neighbor";
                            }
                        }
                    }
                }
            }
            container default-originate {
                presence "enable originate default route to this neighbour";
                tailf:info "Originate default route to this neighbour";
                leaf route-map {
                    tailf:info "Route-map to specify criteria to originate "
                        +"default";
                    type string {
                        tailf:info "WORD;;route-map name";
                    }
                }
            }
            leaf "description" {
                tailf:info "Neighbor specific description";
                tailf:cli-full-command;
                tailf:cli-multi-value;
                type string {
                    tailf:info "LINE;;Up to 80 characters describing this "
                        +"neighbor";
                }
            }
            leaf disable-connected-check {
                tailf:info "One-hop away EBGP peer using loopback address";
                tailf:cli-full-command;
                type empty;
            }
            list distribute-list {
                tailf:info "Filter updates to/from this neighbor";
                tailf:cli-suppress-mode;
                key inout;
                leaf inout {
                    type enumeration {
                        enum in {
                            tailf:code-name "dist_in";
                            tailf:info "Filter incoming updates";
                        }
                        enum out {
                            tailf:code-name "dist_out";
                            tailf:info "Filter outgoing updates";
                        }
                    }
                }
                leaf accesslist {
                    tailf:cli-drop-node-name;
                    tailf:cli-prefix-key;
                    type distribute-list-type2;
                    mandatory true;
                }
            }
            leaf dmzlink-bw {
                tailf:info "Propagate the DMZ link bandwidth";
                tailf:cli-full-command;
                type empty;
            }
            container ebgp-multihop {
                tailf:info "Allow EBGP neighbors not on directly connected "
                    +"networks";
                presence "Allow EBGP neighbors not on directly connected "
                    +"networks";
                leaf max-hop {
                    tailf:cli-drop-node-name;
                    type uint8 {
                        range "1..255";
                        tailf:info "<1-255>;;maximum hop count";
                    }
                }
            }
            leaf fall-over {
                tailf:info "session fall on peer route lost";
                tailf:cli-full-command;
                type empty;
            }
            list filter-list {
                tailf:info "Establish BGP filters";
                tailf:cli-suppress-mode;
                key inout;
                leaf inout {
                    type enumeration {
                        enum in {
                            tailf:code-name "filter_in";
                            tailf:info "Filter incoming routes";
                        }
                        enum out {
                            tailf:code-name "filter_out";
                            tailf:info "Filter outgoing routes";
                        }
                    }
                }
                leaf as-path-list {
                    tailf:cli-drop-node-name;
                    tailf:cli-prefix-key;
                    type uint16 {
                        range "1..500";
                        tailf:info "<1-500>;;AS path access list";
                    }
                    mandatory true;
                }
            }

            container inherit {
                tailf:info "Inherit a template";
                leaf peer-policy {
                    tailf:info "Inherit a peer-policy template";
                    tailf:cli-full-command;
                    type string {
                        tailf:info "WORD;;Template name";
                    }
                }
                leaf peer-session {
                    tailf:info "Inherit a peer-session template";
                    tailf:cli-full-command;
                    type string {
                        tailf:info "WORD;;Template name";
                    }
                }
            }
            container local-as {
                tailf:info "Specify a local-as number";
                presence "Specify a local-as number";
                tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                }
                leaf as-no {
                    tailf:cli-drop-node-name;
                    type uint16 {
                        range "1..65535";
                        tailf:info "<1-65535>;;AS number used as local AS";
                    }
                }
                leaf no-prepend {
                    tailf:info "Do not prepend local-as to updates from ebgp "
                        +"peers";
                    type empty;
                }
                leaf replace-as {
                    tailf:info "Replace real AS with local AS in the EBGP "
                        +"updates";
                    type empty;
                }
                leaf dual-as {
                    tailf:info "Accept either real AS or local AS from the "
                        +"ebgp peer";
                    type empty;
                }
            }
            container maximum-prefix {
                tailf:info "Maximum number of prefixes accepted from this peer";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                    tailf:cli-reset-all-siblings;
                }
                leaf max-prefix-no {
                    tailf:cli-drop-node-name;
                    type uint32 {
                        range "1..2147483647";
                        tailf:info "<1-2147483647>;;maximum no. of prefix "
                            +"limit";
                    }
                }
                leaf threshold {
                    tailf:cli-drop-node-name;
                    tailf:cli-break-sequence-commands;
                    type uint8 {
                        range "1..100";
                        tailf:info "<1-100>;;Threshold value (%) at which to "
                            +"generate a warning msg";
                    }
                }
                leaf restart {
                    tailf:cli-full-command;
                    tailf:info "Restart bgp connection after limit is exceeded";
                    type uint16 {
                        range "1..65535";
                        tailf:info "<1-65535>  Restart interval in minutes";
                    }
                }
                leaf warning-only {
                    tailf:cli-full-command;
                    tailf:info "Only give warning message when limit "
                        +"is exceeded";
                    type empty;
                }
            }
            leaf next-hop-self {
                tailf:cli-full-command;
                tailf:info "Disable the next hop calculation for this neighbor";
                type empty;
            }
            leaf next-hop-unchanged {
                tailf:cli-full-command;
                tailf:info "Propagate the iBGP paths's next hop unchanged "
                    +"for this neighbor";
                type empty;
            }
            container password {
                // FIXME: better text pattern and reset siblings
                // also when configuration the text
                tailf:info "Set a password";
                tailf:cli-compact-syntax;
                leaf enctype {
                    tailf:cli-drop-node-name;
                    tailf:cli-incomplete-command;
                    tailf:cli-reset-container;
                    type uint8 {
                        range "0..7";
                        tailf:info "<0-7>;;Encryption type (0 to disable "
                            +"encryption, 7 for proprietary)";
                    }
                    default "0";
                }
                leaf text {
                    tailf:cli-drop-node-name;
                    tailf:cli-full-command;
                    tailf:cli-multi-value;
                    tailf:cli-reset-container;
                    type string {
                        pattern '[a-zA-Z].*';
                        tailf:info "LINE;;The password";
                    }
                }
            }
            list prefix-list {
                tailf:info "Filter updates to/from this neighbor";
                tailf:cli-suppress-mode;
                key inout;
                leaf inout {
                    type enumeration {
                        enum in {
                            tailf:code-name "prefix_in";
                            tailf:info "Filter incoming updates";
                        }
                        enum out {
                            tailf:code-name "prefix_out";
                            tailf:info "Filter outgoing updates";
                        }
                    }
                }
                leaf prefix-list-name {
                    tailf:cli-drop-node-name;
                    tailf:cli-prefix-key;
                    type string {
                        tailf:info "WORD;;Name of a prefix list";
                    }
                    mandatory true;
                }
            }
            leaf remove-private-as {
                tailf:cli-full-command;
                tailf:info "Remove private AS number from outbound updates";
                type empty;
            }
            list route-map {
                tailf:info "Apply route map to neighbor";
                tailf:cli-suppress-mode;
                key inout;
                leaf inout {
                    type enumeration {
                        enum in {
                            tailf:code-name "route_in";
                            tailf:info "Apply map to incoming routes";
                        }
                        enum out {
                            tailf:code-name "route_out";
                            tailf:info "Apply map to outbound routes";
                        }
                    }
                }
                leaf route-map-name {
                    tailf:cli-drop-node-name;
                    tailf:cli-prefix-key;
                    type string {
                        tailf:info "WORD;;Name of route map";
                    }
                    mandatory true;
                }
            }
            leaf route-reflector-client {
                tailf:cli-full-command;
                tailf:info "Configure a neighbor as Route Reflector client";
                type empty;
            }
            container send-community {
                tailf:info "Send Community attribute to this neighbor";
                presence "Send Community attribute to this neighbor";
                leaf send-community-where {
                    tailf:cli-drop-node-name;
                    type enumeration {
                        enum both {
                            tailf:info "Send Standard and Extended Community "
                                +"attributes";
                        }
                        enum extended {
                            tailf:info "Send Extended Community attribute";
                        }
                        enum standard {
                            tailf:code-name "send_standard";
                            tailf:info "Send Standard Community attribute";
                        }
                    }
                }
            }
            container send-label {
                tailf:info "Send NLRI + MPLS Label to this peer";
                leaf send-label-explicit {
                    tailf:cli-drop-node-name;
                    type enumeration {
                        enum explicit-null {
                            tailf:code-name "send_explicit_null";
                            tailf:info "Advertise Explicit Null label in place "
                                +"of Implicit Null";
                        }
                    }
                }
            }
            leaf shutdown {
                tailf:cli-full-command;
                tailf:info "Administratively shut down this neighbor";
                type empty;
            }
            leaf soft-reconfiguration {
                tailf:cli-full-command;
                tailf:info "Per neighbor soft reconfiguration";
                type enumeration {
                    enum inbound {
                        tailf:info "Allow inbound soft reconfiguration for "
                            +"this neighbor";
                    }
                }
            }
            container timers {
                tailf:info "BGP per neighbor timers";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                }
                leaf keepalive-interval {
                    tailf:cli-drop-node-name;
                    tailf:cli-incomplete-command;
                    type uint16 {
                        range "0..65535";
                        tailf:info "<0-65535>;;Keepalive interval";
                    }
                }
                leaf holdtime {
                    tailf:cli-drop-node-name;
                    type uint16 {
                        range "0..65535";
                        tailf:info "<0-65535>;;Holdtime";
                    }
                }
                leaf minimum-neighbor-hold {
                    tailf:cli-drop-node-name;
                    type uint16 {
                        range "0..65535";
                        tailf:info "<0-65535>  Minimum hold time from neighbor";
                    }
                }
            }
            container translate-update {
                tailf:info "Translate Update to MBGP format";
                container ipv4 {
                    tailf:info "Address Family";
                    container multicast {
                        tailf:info "Address Family modifier";
                        presence "Address Family modifier";
                        leaf unicast {
                            tailf:info "Address Family modifier";
                            type empty;
                        }
                    }
                }
            }
            container transport {
                tailf:info "Transport options";
                leaf connection-mode {
                    tailf:info "Specify passive or active connection";
                    type enumeration {
                        enum active {
                            tailf:info "Actively establish the TCP session";
                        }
                        enum passive {
                            tailf:info "Passively establish the TCP session";
                        }
                    }
                }
            }
            container ttl-security {
                tailf:info "BGP ttl security check";
                leaf hops {
                    tailf:info "IP hops";
                    type uint8 {
                        range "1..254";
                        tailf:info "<1-254>;;maximum number of hops";
                    }
                }
            }
            leaf unsupress-map {
                tailf:cli-full-command;
                tailf:info "Route-map to selectively unsuppress suppressed "
                    +"routes";
                type string {
                    tailf:info "WORD;;Name of route map";
                }
            }
            leaf version {
                tailf:cli-full-command;
                tailf:info "Set the BGP version to match a neighbor";
                type uint16 {
                    range "4";
                    tailf:info "<4-4>;;Neighbor's BGP version";
                }
            }
            leaf weight {
                tailf:cli-full-command;
                tailf:info "Set default weight for routes from this neighbor";
                type uint16 {
                    range "0..65535";
                    tailf:info "<0-65535>;;default weight";
                }
            }
        }
        container redistribute {
            tailf:info "Redistribute information from another routing protocol";
            container bgp {
                tailf:info "Border Gateway Protocol (BGP)";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                    tailf:cli-reset-all-siblings;
                }
                leaf as-no {
                    tailf:cli-drop-node-name;
                    type uint16 {
                        range "1..65535";
                        tailf:info "<1-65535>;;Autonomous system number";
                    }
                }
                uses metric-route-map-grouping;
            }
            container connected {
                presence "Connected";
                tailf:info "Connected";
                uses metric-route-map-grouping;
            }
            container dvmrp {
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                }
                presence "Redistribution of DVMRP into BGP IPv4 Multicast";
                tailf:info "Redistribution of DVMRP into BGP IPv4 Multicast";
                uses route-map-metric-grouping;
            }
            container eigrp {
                tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                    tailf:cli-reset-all-siblings;
                }
                leaf as-no {
                    tailf:cli-drop-node-name;
                    type uint16 {
                        range "1..65535";
                        tailf:info "<1-65535>;;Autonomous system number";
                    }
                }
                uses metric-route-map-grouping;
            }
            container isis {
                // FIXME: need special treatment in GW case
                // The Cisco CLI is inconsisten for this container
                // to go from level-1-2 to level-1 you do "no level-2",
                // for example. Also the metric and route-map settings
                // are not consistently available when they should be.
                tailf:info "ISO IS-IS";
                list isis-area {
                    tailf:cli-drop-node-name;
                    key "name";
                    leaf name {
                        type string {
                            tailf:info "WORD;;ISO routing area tag";
                            // match all but 'ip', 'level-.*', 'metric', and
                            // 'route-map'
                            pattern '^([^mlir].*)|(i[^p].*)|(ip..*)|(l[^e].*)|(le[^v].*)|(lev[^e].*)|(leve[^l].*)|(level[^\-].*)|(m[^e].*)|(me[^t].*)|(met[^r].*)|(metr[^i].*)|(metri[^c].*)|(metric..*)*(r[^o].*)|(ro[^u].*)|(rou[^t].*)|(rout[^e].*)|(route[^\-].*)|(route-[^m].*)|(route-m[^a].*)|(route-ma[^p].*)|(route-map..*)$';
                        }
                    }
                    uses redistribute-isis-grouping;
                }
                container "default" {
                    tailf:cli-drop-node-name;
                    uses redistribute-isis-grouping;
                }
            }
            container iso-igrp {
                tailf:info "IGRP for OSI networks";
                list iso-igrp-area {
                    tailf:cli-compact-syntax;
                    tailf:cli-sequence-commands;
                    tailf:cli-drop-node-name;
                    key "name";
                    leaf name {
                        type string {
                            tailf:info "WORD;;Pointer to route-map entries";
                            // match any but route-map
                            pattern '^([^r].*)|(r^[o].*)|(ro[^u].*)|(rou[^t].*)|(rout[^e].*)|(route[^\-].*)|(route-[^m].*)|(route-m[^a].*)|(route-ma[^p])|(route-map..*)';
                        }
                    }
                    uses route-map-metric-grouping;
                }
                container "default" {
                    tailf:cli-compact-syntax;
                    tailf:cli-sequence-commands;
                    uses route-map-metric-grouping;
                }
            }
            container mobile {
                presence "Mobile routes";
                tailf:info "Mobile routes";
                uses metric-route-map-grouping;
            }
            container odr {
                presence "On Demand stub Routes";
                tailf:info "On Demand stub Routes";
                uses metric-route-map-grouping;
            }

            list ospf {
                tailf:info "Open Shortest Path First (OSPF)";
                key "id";
                leaf id {
                    type uint16 {
                        range "1..65535";
                        tailf:info "<1-65535>;;Process ID";
                    }
                }
                list vrf {
                    tailf:info "VPN Routing/Forwarding Instance";
                    key "name";
                    leaf name {
                        type string {
                            tailf:info "WORD;;VPN Routing/Forwarding Instance "
                                +"(VRF) name";
                        }
                    }
                    container match {
                        // FIXME: incomplete and confused
                        tailf:info "Redistribution of OSPF routes";
                    }
                    uses metric-route-map-grouping;
                }
                container non-vrf {
                    tailf:cli-drop-node-name;
                    container match {
                        // FIXME: incomplete and confused
                        tailf:info "Redistribution of OSPF routes";
                    }
                    uses metric-route-map-grouping;
                }
            }
            container rip {
                presence "Routing Information Protocol (RIP)";
                tailf:info "Routing Information Protocol (RIP)";
                uses metric-route-map-grouping;
            }
            container static {
                // FIXME: there are two other options: ip and clns but
                // it is highly unclear what they mean. If you set them
                // in the 7200 box, nothing is shown. Seems broken or I'm
                // missing neccessary parts in my config for them to be
                // displayed.
                presence "Static routes";
                tailf:info "Static routes";
                uses metric-route-map-grouping;
            }
        }
        leaf synchronization {
            tailf:info "Perform IGP synchronization";
            tailf:cli-full-command;
            type empty;
        }
        leaf table-map {
            tailf:cli-full-command;
            tailf:info "Map external entry attributes into routing table";
            type string {
                tailf:info "WORD;;route-map name";
            }
        }
        container timers {
            tailf:info "Adjust routing timers";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
            }
            leaf keepalive-interval {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint16 {
                    range "0..65535";
                    tailf:info "<0-65535>;;Keepalive interval";
                }
            }
            leaf holdtime {
                tailf:cli-drop-node-name;
                type uint16 {
                    range "0..65535";
                    tailf:info "<0-65535>;;Holdtime";
                }
            }
            leaf minimum-neighbor-hold {
                tailf:cli-drop-node-name;
                type uint16 {
                    range "0..65535";
                    tailf:info "<0-65535>  Minimum hold time from neighbor";
                }
            }
        }
    }

    grouping ip-community-list-standard-grouping {
        container deny {
            tailf:info "Specify community to reject";
            presence "Specify community to reject";
            list deny-list {
                tailf:cli-drop-node-name;
                tailf:cli-suppress-mode;
                key "expr";
                leaf expr {
                    tailf:cli-multi-word-key {
                        tailf:cli-max-words 10;
                    }
                    type string {
                        tailf:info "<1-4294967295>  community number
  aa:nn           community number
  internet        Internet (well-known community)
  local-AS        Do not send outside local AS (well-known community)
  no-advertise    Do not advertise to any peer (well-known community)
  no-export       Do not export to next AS (well-known community)
";
                        pattern '((internet)|(local\-AS)|(no\-advertise)|(no\-export)|(\d+:\d+)|(\d+))( (internet)|(local\-AS)|(no\-advertise)|(no\-export)|(\d+:\d+)|(\d+))*';
                    }
                }
            }
        }
        container permit {
            tailf:info "Specify community to accept";
            presence "Specify community to accept";
            list permit-list {
                tailf:cli-drop-node-name;
                tailf:cli-suppress-mode;
                key "expr";
                leaf expr {
                    tailf:cli-multi-word-key {
                        tailf:cli-max-words 10;
                    }
                    type string {
                        tailf:info "<1-4294967295>  community number
  aa:nn           community number
  internet        Internet (well-known community)
  local-AS        Do not send outside local AS (well-known community)
  no-advertise    Do not advertise to any peer (well-known community)
  no-export       Do not export to next AS (well-known community)
";
                        pattern '((internet)|(local-AS)|(no-advertise)|(no-export)|(\d+:\d+)|(\d+))( (internet)|(local-AS)|(no-advertise)|(no-export)|(\d+:\d+)|(\d+))*';
                    }
                }
            }
        }
    }

    grouping ip-community-list-expanded-grouping {
        container deny {
            tailf:info "Specify community to reject";
            presence "Specify community to reject";
            list deny-list {
                tailf:cli-suppress-mode;
                tailf:cli-drop-node-name;
                key "expr";
                leaf expr {
                    tailf:info "LINE;;An ordered list as a regular-expression";
                    tailf:cli-multi-word-key {
                        tailf:cli-max-words 10;
                    }
                    type string;
                }
            }
        }
        container permit {
            tailf:info "Specify community to accept";
            presence "Specify community to accept";
            list permit-list {
                tailf:cli-suppress-mode;
                tailf:cli-drop-node-name;
                key "expr";
                leaf expr {
                    tailf:info "LINE;;An ordered list as a regular-expression";
                    tailf:cli-multi-word-key {
                        tailf:cli-max-words 10;
                    }
                    type string;
                }
            }
        }
    }

    list policy-map {
        tailf:info "Configure QoS Policy Map";
        tailf:cli-mode-name "config-pmap";
        key "name";
        leaf name {
            type string;
            tailf:info "WORD;;policy-map name";
        }

        list class {
            tailf:info "policy criteria";
            tailf:cli-mode-name "config-pmap-c";
            key "name";
            leaf name {
                type class-name-type;
            }

            container bandwidth {
                tailf:info "Bandwidth";
                leaf bits {
                    tailf:cli-drop-node-name;
                    type uint32 {
                        range "8..2000000";
                        tailf:info "<8-2000000>;;Kilo Bits per second";
                    }
                }
                leaf percent {
                    tailf:info "% of total Bandwidth";
                    type uint16 {
                        range "1..100" {
                            tailf:info "<1-100>;;Percentage";
                        }
                    }
                }
                container remaining {
                    tailf:info "% of the remaining bandwidth";
                    leaf persent {
                        tailf:info "% of the remaining bandwidth";
                        type uint16 {
                            range "1..100" {
                                tailf:info "<1-100>;;Percentage";
                            }
                        }
                    }
                }
            }
            container compression {
                tailf:info "Activate Compression";
                presence "Activate Compression";
                container header {
                    tailf:info "configure header compression";
                    presence "configure header compression";
                    leaf ip {
                        tailf:info "configure ip header compression";
                        type enumeration {
                            enum rtp {
                                tailf:code-name "header_rtp";
                                tailf:info "configure rtp header compression";
                            }
                            enum tcp {
                                tailf:info "configure tcp header compression";
                            }
                        }
                    }
                }
            }
            leaf drop {
                tailf:info "Drop all packets";
                tailf:cli-full-command;
                type empty;
            }
            container estimate {
                tailf:info "estimate resources required for this class";
                container bandwidth {
                    presence "bandwidth required to service this class";
                    tailf:info "bandwidth required to service this class";
                    tailf:cli-sequence-commands;
                    tailf:cli-compact-syntax;
                    container delay-one-in {
                        tailf:info "specify QoS target delay";
                        tailf:cli-compact-syntax;
                        tailf:cli-sequence-commands;
                        leaf doi {
                            tailf:cli-drop-node-name;
                            tailf:cli-incomplete-command;
                            type uint32 {
                                range "50..1000000";
                                tailf:info "<50-1000000>;;delay one packet "+
                                    "of N";
                            }
                        }

                        leaf milliseconds {
                            type uint32 {
                                range "8..1000" {
                                    tailf:info "<8-1000>;;worst-case "+
                                        "milliseconds of delay";
                                }
                            }
                        }
                    }
                    leaf drop-one-in {
                        tailf:info "specify QoS target loss rate";
                        type uint32 {
                            tailf:info "<50-1000000>;;drop one packet of N";
                        }
                    }
                }
            }
            leaf fair-queue {
                tailf:info "Enable Flow-based Fair Queuing in this Class";
                tailf:cli-full-command;
                type uint32 {
                    range "16|32|64|128|256|512|1024|2048|4096" {
                        tailf:info "<16-4096>;;Number Dynamic Conversation "+
                            "Queues";
                    }
                }
            }
            leaf netflow-sampler {
                tailf:info "NetFlow action";
                tailf:cli-full-command;
                // should be leafref to sampler
                type string {
                    tailf:info "WORD;;Name of the flow sampler";
                }
            }
            container police {
                // To cover also the syntax where cir, bc and be
                // doesn't have to be explicitly specified
                tailf:info "Police";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-pmap-c-police";
                tailf:cli-incomplete-command;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                }
                leaf cir {
                    tailf:info "Committed information rate";
                    tailf:cli-hide-in-submode;
                    type uint32 {
                        range "8000..2000000000";
                        tailf:info "<8000-2000000000>;;Bits per second";
                    }
                }
                leaf bc {
                    tailf:info "Conform burst";
                    tailf:cli-hide-in-submode;
                    type uint32 {
                        range "1000..512000000";
                        tailf:info "<1000-512000000>;;Burst bytes";
                    }
                }
                leaf be {
                    tailf:info "Excess burst";
                    tailf:cli-hide-in-submode;
                    type uint32 {
                        range "1000..512000000";
                        tailf:info "<1000-512000000>;;Burst bytes";
                    }
                }
                leaf conform-action {
                    tailf:cli-break-sequence-commands;
                    tailf:info "action when rate is less than conform burst";
                    type police-action-type;
                }
                leaf exceed-action {
                    tailf:info "action when rate is within conform and "+
                        "conform + exceed burst";
                    type police-action-type;
                }
                leaf violate-action {
                    tailf:info "action when rate is greater than conform + "+
                        "exceed burst";
                    type police-action-type;
                }
            }
            container priority {
                tailf:info "Strict Scheduling Priority for this Class";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                choice priority-type {
                    mandatory true;
                    leaf kilo-bits {
                        tailf:cli-drop-node-name;
                        type uint32 {
                            range "8..2000000";
                            tailf:info "<8-2000000>;;Kilo Bits per second";
                        }
                    }
                    leaf percent {
                        tailf:info "% of total bandwidth";
                        type uint16 {
                            range "1..100";
                            tailf:info "<1-100>;;percentage";
                        }
                    }
                }
                leaf burst {
                    tailf:cli-drop-node-name;
                    type uint32 {
                        range "32..2000000";
                    }
                }
            }
            leaf queue-limit {
                tailf:info "Queue Max Threshold for Tail Drop";
                tailf:cli-full-command;
                type uint16 {
                    range "1..4096";
                    tailf:info "<1-4096>;;Packets";
                }
            }
            container random-detect {
                tailf:info "Enable Random Early Detection as drop policy";
                container discard-class {
                    tailf:info "parameters for each discard-class value";
                    tailf:cli-compact-syntax;
                    tailf:cli-sequence-commands;
                    leaf dclass {
                        tailf:cli-drop-node-name;
                        tailf:cli-incomplete-command;
                        type uint16 {
                            range "0..7";
                            tailf:info "<0-7>;;discard-class value";
                        }
                    }
                    uses random-detect-grouping;
                }
                leaf discard-class-based {
                    tailf:info "Enable discard-class-based WRED as drop policy";
                    tailf:cli-full-command;
                    type empty;
                }
                container dscp {
                    tailf:info "parameters for each dscp value";
                    tailf:cli-sequence-commands;
                    tailf:cli-compact-syntax;
                    leaf dscp-val {
                        tailf:cli-drop-node-name;
                        tailf:cli-incomplete-command;
                        type dscp-type;
                    }
                    uses random-detect-grouping;
                }
                leaf dscp-based {
                    tailf:info "Enable dscp-based WRED as drop policy";
                    tailf:cli-full-command;
                    type empty;
                }
                leaf ecn {
                    tailf:info "explicit congestion notification";
                    tailf:cli-full-command;
                    type empty;
                }
                leaf exponential-weighting-constant {
                    tailf:info "weight for mean queue depth calculation";
                    tailf:cli-full-command;
                    type uint16 {
                        range "1..16";
                        tailf:info "<1-16>;;integer in 1..16 used in weighted "+
                            "average to mean 2^number";
                    }
                }
                leaf prec-based {
                    tailf:info "Enable precedence-based WRED as drop policy";
                    tailf:cli-full-command;
                    type empty;
                }
                container precedence {
                    tailf:info "parameters for each precedence value";
                    tailf:cli-sequence-commands;
                    tailf:cli-compact-syntax;
                    leaf prec {
                        tailf:cli-drop-node-name;
                        tailf:cli-incomplete-command;
                        type precedence-type2;
                    }
                    uses random-detect-grouping;
                }
            }
            leaf service-policy {
                tailf:info "Configure Flow Next";
                tailf:cli-full-command;
                type string;
            }
            container set {
                tailf:info "Set QoS values";
                leaf atm-clp {
                    tailf:info "Set ATM CLP bit to 1";
                    tailf:cli-full-command;
                    type empty;
                }
                container cos {
                    tailf:info "Set IEEE 802.1Q/ISL class of service/user "+
                        "priority";
                    tailf:cli-compact-syntax;
                    tailf:cli-sequence-commands;
                    choice cos-type {
                        case a {
                            leaf val {
                                type uint16 {
                                    range "0..7";
                                    tailf:info "<0-7>;;cos value";
                                }
                            }
                        }
                        case b {
                            leaf pack {
                                type enumeration {
                                    enum dscp {
                                        tailf:code-name "pack_dscp";
                                        tailf:info "Set value from packet dscp";
                                    }
                                    enum precedence {
                                        tailf:code-name "pack_precedence";
                                        tailf:info "Set value from packet "+
                                            "precedence.";
                                    }
                                }
                            }
                            leaf table {
                                tailf:info "Set codepoint value based on "+
                                    "tablemap.";
                                type string {
                                    tailf:info "WORD;;table-map name";
                                }
                            }
                        }
                    }
                }
                leaf discard-class {
                    tailf:info "Discard behavior identifier";
                    tailf:cli-full-command;
                    type uint16 {
                        range "0..7";
                        tailf:info "<0-7>;;Discard Class value";
                    }
                }
                leaf dscp {
                    tailf:info "Set DSCP in IP(v4) and IPv6 packets";
                    tailf:cli-full-command;
                    type dscp-type;
                }
                leaf fr-de {
                    tailf:info "Set FR DE bit to 1";
                    tailf:cli-full-command;
                    type empty;
                }
                container ip {
                    tailf:info "Set IP specific values";
                    choice ip-choice {
                        leaf dscp {
                            tailf:info "Set IP DSCP (DiffServ CodePointint)";
                            type dscp-type;
                        }
                        container precedence {
                            tailf:info "Set IP precedence";
                            presence "Set IP precedence";
                            leaf precedence-val {
                                tailf:cli-drop-node-name;
                                type precedence-type;
                            }
                        }
                    }
                }
            }
            container shape {
                tailf:info "Traffic Shaping";
                leaf adaptive {
                    tailf:info "Enable Traffic Shaping adaptation to BECN";
                    tailf:cli-full-command;
                    type uint32 {
                        range "8000..154400000";
                        tailf:info "<8000-154400000>;;Lower Bound Target Bit "+
                            "Rate (bits per second)";
                    }
                }
                container average {
                    tailf:info "configure token bucket: CIR (bps) [Bc (bits) "+
                        "[Be (bits)]], send out Bc only per interval";
                    tailf:cli-sequence-commands;
                    tailf:cli-compact-syntax;
                    choice average-choice {
                        case a {
                            leaf bit-rate {

                                tailf:cli-drop-node-name;
                                type uint32 {
                                    range "8000..154400000";
                                    tailf:info "<8000-154400000>;;Target Bit "+
                                        "Rate (bits per second), the value "+
                                        "needs to be a multiple of 8000";
                                }
                            }
                            leaf bits-per-interval-sustained {
                                tailf:cli-drop-node-name;
                                type uint32 {
                                    range "256..154400000";
                                    tailf:info "<256-154400000>;;bits per "+
                                        "interval, sustained. Needs to be "+
                                        "multiple of 128. Recommend not to "+
                                        "configure it, the algorithm will "+
                                        "find out the best value";
                                }
                            }
                            leaf bits-per-interval-excess {
                                tailf:cli-drop-node-name;
                                type uint32 {
                                    range "0..154400000";
                                    tailf:info "<0-154400000>;;bits per "+
                                        "interval, excess. Needs to be "+
                                        "multiple of 128. Bc will be used if "+
                                        "you don't configure it.";
                                }
                            }
                        }
                        case b {
                            leaf percent {
                                tailf:info "% of interface bandwidth for "+
                                    "Committed information rate";
                                type uint16 {
                                    range "1..100";
                                    tailf:info "<1-100>;;Percentage";
                                }
                            }
                            leaf burst-size-sustained {
                                tailf:cli-incomplete-command;
                                tailf:cli-drop-node-name;
                                type uint16 {
                                    range "10..2000";
                                    tailf:info "<10-2000>;;Sustained burst "+
                                        "size in msec";
                                }
                            }
                            leaf ms {
                                tailf:info "milliseconds";
                                type empty;
                            }
                            container bse {
                                tailf:cli-drop-node-name;
                                tailf:cli-flatten-container;
                                tailf:cli-sequence-commands;
                                tailf:cli-compact-syntax;
                                leaf burst-size-excess {
                                    tailf:cli-incomplete-command;
                                    type uint16 {
                                        range "10..2000";
                                        tailf:info "<10-2000>;;Excess burst "+
                                            "size in msec";
                                    }
                                }
                                leaf ms {
                                    tailf:info "milliseconds";
                                    type empty;
                                }
                            }
                        }
                    }
                }
                leaf fecn-adapt {
                    tailf:info "Enable Traffic Shaping reflection of FECN as "+
                        "BECN";
                    tailf:cli-full-command;
                    type empty;
                }
                container fr-voice-adapt {
                    tailf:info "Enable rate adjustment depending on voice "+
                        "presence";
                    presence "Enable rate adjustment depending on voice "+
                        "presence" ;
                    leaf deactivation {
                        type uint16 {
                            range "1..10000";
                            tailf:info "<1-10000>;;de-activation delay in "+
                                "seconds";
                        }
                    }
                }
                leaf max-buffers {
                    tailf:cli-full-command;
                    tailf:info "Set Maximum Buffer Limit";
                    type uint16 {
                        range "1..4096";
                        tailf:info "<1-4096>;;Maximum Buffer Limit";
                    }
                }
            }
        }
        leaf description {
            tailf:info "Policy-Map description";
            tailf:cli-multi-value;
            type string {
                length "1..200";
                tailf:info "LINE;;Description of this policy-map (up to "
                    +"200 characters)";
            }
        }
    }

    container ip {
        leaf routing {
            tailf:info "Enable IP routing";
            tailf:cli-full-command;
            type empty;
        }

        tailf:info "Global IP configuration subcommands";
        list vrf {
            tailf:info "Configure an IP VPN Routing/Forwarding instance";
            key "name";

            leaf name {
                type string;
                tailf:info "WORD;;VPN Routing/Forwarding instance name";
            }

            container bgp {
                tailf:info "Commands pertaining to BGP";

                container next-hop {
                    tailf:info "Next-hop for the routes of a VRF in the "
                        +"backbone";
                    leaf Loopback {
                        tailf:info "Loopback interface number";
                        // FIXME: merge key and value, ie Loopback 3
                        // should become Loopback3
                        type uint32 {
                            range "0..2147483647";
                            tailf:info "<0-2147483647>;;Loopback interface "
                                +"number";
                        }
                    }
                }
            }
            leaf context {
                tailf:info "Associate SNMP context with this vrf";
                type string {
                    tailf:info "WORD;;SNMP Context Name";
                }
            }
            // The 'default' command should be added as a clispec command
            leaf description {
                tailf:info "VRF specific description";
                tailf:cli-multi-value;
                type string {
                    length "1..244";
                    tailf:info "LINE;;Up to 244 characters describing this VRF";
                }
            }
            container export {
                tailf:info "VRF export";
                leaf map {
                    tailf:info "Route-map based VRF export";
                    type string {
                        tailf:info "WORD;;VRF export route-map name";
                    }
                }
            }
            container import {
                // NOTE: needs special treatment when talking to backend
                // broken in real c7200 CLI
                tailf:info "VRF import";
                choice import-choice {
                    leaf map {
                        tailf:info "Route-map based VRF import";
                        type string {
                            tailf:info "WORD;;VRF import route-map name";
                        }
                    }
                    container ipv4 {
                        tailf:cli-compact-syntax;
                        tailf:cli-sequence-commands;
                        tailf:info "Address family based VRF import";
                        leaf ipv4-type {
                            tailf:cli-drop-node-name;
                            type enumeration {
                                enum unicast {
                                    tailf:code-name "ipv41_unicast";
                                    tailf:info "Import prefixes from IPv4 "
                                        +"Unicast table";
                                }
                                enum multicast {
                                    tailf:code-name "ipv41_multicast";
                                    tailf:info "Import prefixes from IPv4 "
                                        +"Multicast tabl";
                                }
                            }
                        }
                        leaf upper-limit {
                            tailf:cli-break-sequence-commands;
                            tailf:cli-drop-node-name;
                            type uint32 {
                                range "1..2147483647";
                                tailf:info "<1-2147483647>;;Upper limit"
                                    +" on import prefixes without "
                                    +"hogging memory";
                            }
                        }
                        leaf map {
                            tailf:info "Route-map based VRF import";
                            type string {
                                tailf:info "WORD;;VRF import route-map "
                                    +"name";
                            }
                        }
                    }
                }
            }
            container maximum {
                tailf:info "Maximum number of routes allowed in this routing "
                    +"table";
                tailf:cli-incomplete-command;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                presence "Maximum number of routes allowed in this routing "
                    +"table";
                leaf routes {
                    tailf:info "Maximum number of routes allowed in this "
                        +"routing table";
                    tailf:cli-incomplete-command;
                    type uint32 {
                        range "1..4294967295";
                        tailf:info "<1-4294967295>;;Maximum number of routes "
                            +"allowed";
                    }
                }
                choice maximum-choice {
                    mandatory true;
                    case threshold-case {
                        leaf threshold {
                            tailf:cli-drop-node-name;
                            tailf:info "";
                            type uint16 {
                                range "1..100";
                                tailf:info "<1-100>;;Threshold value (%) at "
                                    +"which to generate a warning msg";
                            }
                        }
                        leaf reinstall {
                            tailf:info "Reinstall previous rejected route due "
                                +"to over maximum route limit";
                            type uint16 {
                                range "1..100";
                                tailf:info "<1-100>;;Threshold value (%) at "
                                    +"which to reinstall routes back to VRF";
                            }
                        }
                    }
                    case warning-case {
                        leaf warning-only {
                            tailf:info "Only give a warning message if is "
                                +"limit exceeded";
                            type empty;
                        }
                    }
                }
            }
            container mdt {
                tailf:info "Backbone Multicast Distribution Tree";
                tailf:cli-incomplete-command;
                presence "Backbone Multicast Distribution Tree";
                leaf default {
                    tailf:info "The default group";
                    type inet:ipv4-address {
                        tailf:info "A.B.C.D;;IP multicast group address";
                    }
                }
                leaf log-reuse {
                    tailf:info "Event logging for data MDT reuse";
                    type empty;
                }
                container data {
                    tailf:info "MDT data group range";
                    tailf:cli-compact-syntax;
                    tailf:cli-sequence-commands;
                    tailf:cli-incomplete-command;
                    leaf mulicast-address {
                        tailf:cli-drop-node-name;
                        tailf:cli-incomplete-command;
                        type inet:ipv4-address {
                            tailf:info "A.B.C.D;;IP multicast group address";
                        }
                    }
                    leaf wildcard-bits {
                        tailf:cli-drop-node-name;
                        type inet:ipv4-address {
                            tailf:info "A.B.C.D;;Wildcard bits";
                        }
                    }
                    choice mdt-data-choice {
                        case mdt-data-threshold {
                            leaf threshold {
                                tailf:info "MDT switching threshold";
                                type uint32 {
                                    tailf:info "<1-4294967>;;Traffic rate in "
                                        +"kilobits per second";
                                    range "1..4294967";
                                }
                            }
                            leaf threshold-list {
                                tailf:alt-name "list";
                                tailf:info "Access-list";
                                type mdt-data-list-type;
                            }
                        }
                        case mdt-data-list {
                            leaf list {
                                tailf:info "Access-list";
                                type mdt-data-list-type;
                            }
                        }
                    }
                }
            }
            leaf rd {
                tailf:info "Specify Route Distinguisher";
                type rd-type;
            }
            list route-target {
                tailf:info "Specify Target VPN Extended Communities";
                tailf:cli-suppress-mode;
                key "direction target";

                // NOTE: the Cisco CLI does not require you to give
                // the direction, it will default to 'export' if not
                // given.

                leaf direction {
                    type enumeration {
                        enum "both" {
                            tailf:info "Both import and export Target-VPN "
                                +"community";
                        }
                        enum "export" {
                            tailf:code-name "direction_export";
                            tailf:info "Export Target-VPN community";
                        }
                        enum "import" {
                            tailf:code-name "direction_import";
                            tailf:info "Import Target-VPN community";
                        }
                    }
                }

                leaf target {
                    type rd-type {
                        tailf:info "ASN:nn or IP-address:nn;;Target VPN "
                            +"Extended Community";
                    }
                }

            }
            container vpn {
                tailf:info "Configure VPN ID as specified in rfc2685";
                leaf id {
                    tailf:info "Configure VPN ID in rfc2685 format";
                    type vpn-id-type;
                }
            }
        }
        container community-list {
            tailf:info "Add a community list entry";

            // FIXME: in the GW case we need special treatment of 'no'
            // For example, no ip community-list 1 deny internet will
            // actually delete the community-list 1 instance.

            list number-standard {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                tailf:cli-suppress-mode;
                key no;
                leaf no {
                    type uint16 {
                        range "1..99";
                        tailf:info "<1-99>;;Community list number (standard)";
                    }
                }
                uses ip-community-list-standard-grouping;
            }
            list number-expanded {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                tailf:cli-suppress-mode;
                key no;
                leaf no {
                    type uint16 {
                        range "100..500";
                        tailf:info "<100-500>;;Community list number "
                            +"(expanded)";
                    }
                }
                uses ip-community-list-expanded-grouping;
            }
            list expanded {
                tailf:info "Add an expanded community-list entry";
                tailf:cli-incomplete-command;
                tailf:cli-suppress-mode;
                key name;
                leaf name {
                    type string {
                        tailf:info "WORD;;Community list name";
                    }
                }
                uses ip-community-list-expanded-grouping;
            }
            list standard {
                tailf:info "Add a standard community-list entry";
                tailf:cli-incomplete-command;
                tailf:cli-suppress-mode;
                key name;
                leaf name {
                    type string {
                        tailf:info "WORD;;Community list name";
                    }
                }
                uses ip-community-list-standard-grouping;
            }
        }

        container prefix-list {
            tailf:info "Build a prefix list";
            list prefixes {
                tailf:cli-drop-node-name;
                tailf:cli-suppress-mode;
                key "name";
                leaf "name" {
                    type string {
                        tailf:info "WORD;;Name of a prefix list";
                        pattern '([^s].*)|(s[^e].*)|(se[^q].*)(seq[^u].*)|(sequ[^e].*)|(seque[^n].*)|(sequen[^c].*)|(sequenc[^e].*)|(sequence[^\-].*)|(sequence\-[^n].*)|(sequence\-n[^u].*)|(sequence\-nu[^m].*)|(sequence\-num[^b].*)|(sequence\-numb[^e].*)|(sequence\-numbe[^r].*)|(sequence\-number..*)';
                    }
                }
                leaf description {
                    tailf:info "Prefix-list specific description";
                    tailf:cli-multi-value;
                    tailf:cli-full-command;
                    type string {
                        length "1..80";
                        tailf:info "LINE;;Up to 80 characters describing this "
                            +"prefix-list";
                    }
                }
                list seq {
                    // NOTE: the seq element is not actually mandatory
                    // in the Cisco CLI. If it isn't give
                    tailf:info "sequence number of an entry";
                    tailf:cli-suppress-mode;
                    key "no";
                    leaf no {
                        type uint32 {
                            range "1..4294967294";
                            tailf:info "<1-4294967294>;;Sequence number";
                        }
                        tailf:key-default "10";
                    }
                    container deny {
                        tailf:info "Specify packets to reject";
                        tailf:cli-sequence-commands {
                            tailf:cli-reset-all-siblings;
                        }
                        tailf:cli-compact-syntax;
                        leaf ip {
                            tailf:cli-drop-node-name;
                            type inet:ipv4-prefix {
                                tailf:info "A.B.C.D;;IP prefix <network>/"
                                    +"<length>, e.g., 35.0.0.0/8";
                            }
                        }
                        leaf ge {
                            tailf:info "Minimum prefix length to be matched";
                            tailf:cli-break-sequence-commands;
                            type uint8 {
                                range "1..32";
                                tailf:info "<1-32>;;Minimum prefix length";
                            }
                        }
                        leaf le {
                            tailf:info "Maximum prefix length to be matched";
                            tailf:cli-full-command;
                            type uint8 {
                                range "1..32";
                                tailf:info "<1-32>;;Maximum prefix length";
                            }
                        }
                    }
                    container permit {
                        tailf:info "Specify packets to forward";
                        tailf:cli-sequence-commands {
                            tailf:cli-reset-all-siblings;
                        }
                        tailf:cli-compact-syntax;
                        leaf ip {
                            tailf:cli-drop-node-name;
                            type inet:ipv4-prefix {
                                tailf:info "A.B.C.D;;IP prefix <network>/"
                                    +"<length>, e.g., 35.0.0.0/8";
                            }
                        }
                        leaf ge {
                            tailf:info "Minimum prefix length to be matched";
                            tailf:cli-break-sequence-commands;
                            type uint8 {
                                range "1..32";
                                tailf:info "<1-32>;;Minimum prefix length";
                            }
                        }
                        leaf le {
                            tailf:info "Maximum prefix length to be matched";
                            tailf:cli-full-command;
                            type uint8 {
                                range "1..32";
                                tailf:info "<1-32>;;Maximum prefix length";
                            }
                        }
                    }
                }
            }
            leaf sequence-number {
                tailf:info "Include/exclude sequence numbers in NVGEN";
                tailf:cli-full-command;
                type empty;
            }
        }
        container as-path {
          tailf:info "BGP autonomous system path filter";

          list access-list {
            tailf:cli-suppress-mode;
            tailf:info "Specify an access list number";
            tailf:cli-sequence-commands;
            tailf:cli-incomplete-command;
            tailf:cli-compact-syntax;


            key "name";
            leaf name {
              tailf:cli-incomplete-command;
              type uint16 {
                range "1..500";
                tailf:info "<1-500>;;AS path access list number";
              }
            }
            leaf operation {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type enumeration {
                enum deny {
                  tailf:code-name "operation_deny";
                  tailf:info "Specify packets to reject";
                }
                enum permit {
                  tailf:code-name "operation_permit";
                  tailf:info "Specify packets to forward";
                }
              }
            }
            leaf as-path {
              tailf:cli-drop-node-name;
              tailf:cli-full-command;
              type string {
                tailf:info "LINE;;A regular-expression to match BGP AS paths.";
              }
            }



          }
        }
    }
    container router {
        tailf:info "Enable a routing process";

        list bgp {
            tailf:info "Border Gateway Protocol (BGP)";
            key "as-no";
            max-elements 1;

            leaf as-no {
                tailf:cli-suppress-range;
                type uint16 {
                    range "1..65535";
                    tailf:info "<1-65535>;;Autonomous system number";
                }
            }

            container address-family {
                tailf:info "Enter Address Family command mode";
                list ipv4 {
                    tailf:info "Address family";
                    tailf:cli-exit-command "exit-address-family" {
                        tailf:info "Exit from Address Family configuration "
                            +"mode";
                    }
                    key "unicast-multicast";
                    leaf unicast-multicast {
                        type enumeration {
                            enum unicast {
                                tailf:code-name "ipv42_unicast";
                                tailf:info "Address Family modifier";
                            }
                            enum multicast{
                                tailf:code-name "ipv42_multicast";
                                tailf:info "Address Family modifier";
                            }
                        }
                        tailf:key-default "unicast";
                    }
                    list vrf {
                        key "name";
                        leaf name {
                            type string {
                                tailf:info "WORD;;VPN Routing/Forwarding "
                                    +"instance name";
                            }
                        }
                        uses address-family-grouping;
                    }
                    uses address-family-grouping;
                }
                list ipv6 {
                    tailf:info "Address family";
                    tailf:cli-exit-command "exit-address-family" {
                        tailf:info "Exit from Address Family configuration "
                            +"mode";
                    }
                    key "unicast-multicast";
                    leaf unicast-multicast {
                        type enumeration {
                            enum unicast {
                                tailf:code-name "ipv6_unicast";
                                tailf:info "Address Family modifier";
                            }
                            enum multicast{
                                tailf:code-name "ipv6_multicast";
                                tailf:info "Address Family modifier";
                            }
                        }
                        tailf:key-default "unicast";
                    }
                    uses address-family-grouping;
                }
                list vpnv4 {
                    tailf:info "Address family";
                    tailf:cli-exit-command "exit-address-family" {
                        tailf:info "Exit from Address Family configuration "
                            +"mode";
                    }
                    key "unicast-multicast";
                    leaf unicast-multicast {
                        type enumeration {
                            enum unicast {
                                tailf:code-name "vpnv4_unicast";
                                tailf:info "Address Family modifier";
                            }
                        }
                        tailf:key-default "unicast";
                    }
                    uses address-family-grouping;
                }
                list nsap {
                    tailf:info "Address family";
                    tailf:cli-exit-command "exit-address-family" {
                        tailf:info "Exit from Address Family configuration "
                            +"mode";
                    }
                    key "unicast-multicast";
                    leaf unicast-multicast {
                        type enumeration {
                            enum unicast {
                                tailf:code-name "nsap_unicast";
                                tailf:info "Address Family modifier";
                            }
                        }
                        tailf:key-default "unicast";
                    }
                    uses address-family-grouping;
                }
            }
            uses address-family-grouping;
            container template {
                tailf:info "Enter template command mode";
                list peer-policy {
                    tailf:info "Template configuration for policy parameters";
                    tailf:cli-exit-command "exit-peer-policy" {
                        tailf:info "Exit from template configuration mode";
                    }
                    key name;
                    leaf name {
                        type string {
                            tailf:info "WORD;;Name of peer-policy template";
                        }
                    }
                    // FIXME: essentailly neighbour settings
                }
                list peer-session {
                    tailf:info "Template configuration for session parameters";
                    tailf:cli-exit-command "exit-peer-session" {
                        tailf:info "Exit from template configuration mode";
                    }
                    key name;
                    leaf name {
                        type string {
                            tailf:info "WORD;;Name of peer-session template";
                        }
                    }
                    // FIXME: essentailly neighbour settings
                }
            }
        }
    }

    container mpls {
        tailf:info "Configure MPLS parameters";

        container atm {
            tailf:info "Configure ATM options";
            leaf disable-headend-vc {
                tailf:info "Dedicated lsc capability: In this mode "
                    +"headend Tag VCs are disabled.";
                type empty;
            }
        }
        leaf cos-map {
            tailf:info "Configure MPLS CoS ATM Multi-VC CoS Map";
            tailf:cli-full-command;
            type uint8 {
                range "1..255" {
                    tailf:info "<1-255>;;cos-map number";
                }
            }
        }
        container ip {
            tailf:info "Dynamic MPLS forwarding for IP";
            presence "Dynamic MPLS forwarding for IP";

            leaf default-route {
                tailf:info "Allow MPLS forwarding for ip default route";
                tailf:cli-full-command;
                type empty;
            }
            leaf propagate-ttl {
                tailf:info "Propagate IP TTL into the label stack";
                tailf:cli-full-command;
                type boolean;
                default "true";
                tailf:cli-trim-default;
                tailf:cli-boolean-no;
            }
            container ttl-expiration {
                tailf:info "Control MPLS TTL expiration behavior";
                leaf pop {
                    tailf:info "Popping labels on TTL expiration";
                    type uint8 {
                        range "1..6";
                        tailf:info "<1-6>;;Popping all labels if original "
                            +"packet has less than N labels";
                    }
                }
            }
        }
        container label {
            tailf:info "Label properties";
            container atm {
                tailf:info "Configure ATM options";
                leaf disable-headend-vc {
                    tailf:info "Dedicated lsc capability: In this mode "
                        +"headend Tag VCs are disabled.";
                    type empty;
                }
            }
            leaf protocol {
                tailf:info "Set platform default label distribution protocol";
                tailf:cli-full-command;
                type enumeration {
                    enum ldp {
                        tailf:code-name "label_ldp";
                        tailf:info "Use LDP (default)";
                    }
                    enum tdp: {
                        tailf:code-name "label_tdp";
                        tailf:info "Use TDP";
                    }
                }
                default ldp;
            }
            container range {
                tailf:info "Label range";
                tailf:cli-sequence-commands;
                tailf:cli-compact-syntax;
                leaf min {
                    tailf:cli-drop-node-name;
                    tailf:cli-incomplete-command;
                    type uint32 {
                        range "16..1048575";
                        tailf:info "<16-1048575>  Minimum label value";
                    }
                }
                leaf max {
                    tailf:cli-drop-node-name;
                    type uint32 {
                        range "16..1048575";
                        tailf:info "<16-1048575>  Maximum label value";
                    }
                }
            }
        }
        container ldp {
            tailf:info "Label Distribution Protocol";
            container advertise-labels {
                tailf:info "Label advertisements";
                container "for" {
                    tailf:info "Access-list specifying controls on "
                        +"destination prefixes";
                    tailf:cli-sequence-commands;
                    tailf:cli-compact-syntax;
                    leaf from {
                        tailf:cli-drop-node-name;
                        type string {
                            tailf:info "WORD;;IP access-list for destination "
                                +"prefixes; name or number (1-99)";
                        }
                    }
                    leaf to {
                        tailf:info "Access-list specifying controls on LDP "
                            +"peers";
                        type string {
                            tailf:info "WORD;;IP access-list for LDP peers; name "
                                +"or number (1-99)";
                        }
                    }
                }
                container interface {
                    tailf:info "Advertise /32 interface address";
                    list FastEthernet {
                        tailf:info "FastEthernet IEEE 802.3";
                        tailf:cli-allow-join-with-key {
                            tailf:cli-display-joined;
                        }
                        tailf:cli-suppress-mode;
                        key "name";
                        leaf name {
                            type leafref {
                                path "/c:interface/FastEthernet/name";
                            }
                        }
                    }
                    // FIXME: add all other types of supported interfaces
                }
                leaf oldstyle {
                    tailf:info "Use old style (TDP) method for matching "
                        +"prefix acl";
                    tailf:cli-full-command;
                    type empty;
                }
            }
            container atm {
                tailf:info "Configure ATM MPLS options";
                leaf control-mode {
                    tailf:info "Select LSP setup control mode for MPLS VCs";
                    tailf:cli-full-command;
                    type enumeration {
                        enum independent {
                            tailf:info "Independent Downstream on Demand "
                                +"Label VC setup";
                        }
                        enum ordered {
                            tailf:info "Ordered Dowstream on Demand Label "
                                +"VC setup";
                        }
                    }
                    default "ordered";
                    tailf:cli-trim-default;
                }
                leaf vc-merge {
                    tailf:info "Select VC merge capability";
                    tailf:cli-full-command;
                    tailf:cli-boolean-no;
                    tailf:cli-trim-default;
                    type boolean;
                    default "true";
                }
            }
            container backoff {
                tailf:info "Set LDP session backoff parameters";
                tailf:cli-sequence-commands;
                tailf:cli-compact-syntax;
                leaf initial {
                    tailf:cli-drop-node-name;
                    tailf:cli-incomplete-command;
                    type uint32 {
                        tailf:info "<5-2147483>;;Initial session backoff "
                            +"time (seconds)";
                        range "5..2147483";
                    }
                }
                leaf max {
                    tailf:cli-drop-node-name;
                    type uint32 {
                        tailf:info "<5-2147483>;;Maximum session backoff "
                            +"time (seconds)";
                        range "5..2147483";
                    }
                }
            }
            container discovery {
                tailf:info "LDP discovery";
                container hello {
                    tailf:info "LDP discovery Hello";
                    leaf holdtime {
                        tailf:info "LDP discovery Hello holdtime";
                        type uint16 {
                            tailf:info "<1-65535>;;Holdtime in seconds";
                            range "1..65535";
                        }
                    }
                    leaf interval {
                        tailf:info "LDP discovery Hello interval";
                        tailf:cli-full-command;
                        type uint16 {
                            tailf:info "<1-65535>;;Hello interval in "
                                +"seconds";
                            range "1..65535";
                        }
                    }
                }
                container targeted-hello {
                    tailf:info "LDP discovery Targeted Hello";
                    container accept {
                        tailf:info "Accept targeted hellos";
                        presence "Accept targeted hellos";
                        leaf from {
                            tailf:info "Access list to specify acceptable "
                                +"targeted hello sources";
                            type string {
                                tailf:info "WORD;;IP access-list for "
                                    +"acceptable targeted hello sources";
                            }
                        }
                    }
                    leaf holdtime {
                        tailf:info "LDP discovery Hello holdtime";
                        type uint16 {
                            tailf:info "<1-65535>;;Holdtime in seconds";
                            range "1..65535";
                        }
                    }
                    leaf interval {
                        tailf:info "LDP discovery Hello interval";
                        tailf:cli-full-command;
                        type uint16 {
                            tailf:info "<1-65535>;;Hello interval in "
                                +"seconds";
                            range "1..65535";
                        }
                    }
                }
            }
            container explicit-null {
                tailf:info "Advertise Explicit Null label in place of "
                    +"Implicit Null";
                presence "Advertise Explicit Null label in place of "
                    +"Implicit Null";
                leaf "for" {
                    tailf:info "Access-list specifying controls on "
                        +"destination prefixes";
                    type string {
                        tailf:info "WORD;;IP access-list for destination "
                            +"prefixes; name or number (1-99)";
                    }
                }
                leaf "to" {
                    tailf:info "Access-list specifying controls on LDP peers";
                    type string {
                        tailf:info "WORD;;IP access-list for LDP "
                            +"peers; name or number (1-99)";
                    }
                }
            }
            container graceful-restart {
                tailf:info "Configure Graceful Restart timers";
                presence "Configure Graceful Restart timers";
                container timers {
                    tailf:info "Configure Graceful Restart timers";
                    leaf forwarding-holding {
                        tailf:info "Forwarding State Holding time";
                        tailf:cli-full-command;
                        type uint16 {
                            tailf:info "<30-600>;;seconds";
                            range "30..600";
                        }
                    }
                    leaf max-recovery {
                        tailf:info "Max-Recovery time";
                        tailf:cli-full-command;
                        type uint16 {
                            tailf:info "<15-600>;;seconds";
                            range "15..600";
                        }
                    }
                    leaf neighbor-liveness {
                        tailf:info "Neighbor-Liveness time";
                        tailf:cli-full-command;
                        type uint16 {
                            range "5..600";
                            tailf:info "<5-300>;;seconds";
                        }
                    }
                }
            }
            leaf holdtime {
                tailf:info "LDP session holdtime";
                tailf:cli-full-command;
                type uint32 {
                    tailf:info "<15-2147483>;;Holdtime in seconds";
                    range "15..2147483";
                }
            }
            container logging {
                tailf:info "Enable LDP logging";
                leaf neighbor-changes {
                    tailf:info "Log LDP neighbor state changes";
                    type empty;
                }
            }
            leaf loop-detection {
                tailf:info "Enable LDP Loop Detection";
                tailf:cli-full-command;
                type empty;
            }
            leaf maxhops {
                tailf:info "Limit hop count for LDP LSP setup";
                tailf:cli-full-command;
                type uint8 {
                    range "0..255";
                    tailf:info "<1-255>;;Maximum hop count value";
                }
            }
            list neighbor {
                tailf:info "Configure neighbor parameters";
                tailf:cli-suppress-mode;
                key "address";
                leaf address {
                    type inet:ipv4-address {
                        tailf:info "A.B.C.D;;IP address for LDP neighbor";
                    }
                }
                leaf implicit-withdraw {
                    tailf:info "Enable LDP Implicit Withdraw Label";
                    tailf:cli-full-command;
                    type empty;
                }
                container lables {
                    tailf:info "Configure label binding exchange controls";

                    leaf accept {
                        tailf:info "Specify label bindings to accept";
                        type string {
                            tailf:info "WORD;;IP access-list for LDP "
                                +"peers; name or number (1-99)";
                        }
                    }
                }
                container password {
                    // FIXME: better text pattern and reset siblings
                    // also when configuration the text
                    tailf:info "Set a password";
                    tailf:cli-compact-syntax;
                    leaf enctype {
                        tailf:cli-drop-node-name;
                        tailf:cli-incomplete-command;
                        tailf:cli-reset-container;
                        type uint8 {
                            range "0..7";
                            tailf:info "<0-7>;;Encryption type (0 to disable "
                                +"encryption, 7 for proprietary)";
                        }
                        default "0";
                    }
                    leaf text {
                        tailf:cli-drop-node-name;
                        tailf:cli-full-command;
                        tailf:cli-multi-value;
                        tailf:cli-reset-container;
                        type string {
                            pattern '[a-zA-Z].*';
                            tailf:info "LINE;;The password";
                        }
                    }
                }
                container targeted {
                    tailf:info "Establish targeted session";
                    presence "Establish targeted session";
                    leaf protocol {
                        tailf:cli-drop-node-name;
                        type enumeration {
                            enum ldp {
                                tailf:code-name "target_ldp";
                                tailf:info "User LDP";
                            }
                            enum tdp {
                                tailf:code-name "target_tdp";
                                tailf:info "Use TDP";
                            }
                        }
                    }
                }
            }
            container request-labels {
                tailf:info "Access list to specify valid downstream "
                    +"on demand destinations.";
                leaf "for" {
                    tailf:info "Access list to specify acceptable "
                        +"downstream on demand destinations";
                    type string {
                        tailf:info "WORD;;IP access-list for destination "
                            +"prefixes; name or number (1-99)";
                    }
                }
            }
            container router-id {
                tailf:info "Select interface to prefer for LDP "
                    +"identifier address";
                tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                }
                tailf:cli-compact-syntax;
                leaf interface {
                    tailf:cli-drop-node-name;
                    type string {
                        tailf:info "WORD;;intrace name";
                    }
                }
                leaf force {
                    tailf:info "Forcibly change the LDP router id";
                    type empty;
                }
            }
        }
        container prefix-map {
            tailf:info "Configure MPLS CoS Tag-VC Multi-VC Prefix Map";
            tailf:cli-sequence-commands;
            tailf:cli-compact-syntax;
            leaf nr {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                    range "1..255";
                    tailf:info "<1-255>;;prefix-map number";
                }
            }
            leaf access-list {
                tailf:info "Configure access-list for this prefix-map";
                tailf:cli-incomplete-command;
                type uint8 {
                    range "1..255";
                    tailf:info "<1-255>;;access-list number";
                }
            }
            leaf cos-map {
                tailf:info "Configure cos-map for this prefix-map";
                type uint8 {
                    range "1..255";
                    tailf:info "<1-255>;;cos-map number";
                }
            }
        }
        container traffic-eng {
            tailf:info "Configure Traffic Engineering parameters";

            container auto-bw {
                tailf:info "auto-bw parameters";
                container timers {
                    tailf:info "Enable auto-bw Timers Collection and Application";
                    presence "Enable auto-bw Timers Collection and Application";
                    leaf frequency {
                        tailf:info "Interval between auto-bw data collection";
                        type uint32 {
                            tailf:info "<1-604800>;;seconds between auto-bw";
                            range "1..604800";
                        }
                    }
                }
            }
            container link-management {
                tailf:info "Link Management configuration";
                container timers {
                    tailf:info "Link Management timers configuration";
                    leaf bandwidth-hold {
                        tailf:info "Link Management bandwidth hold timer";
                        tailf:cli-full-command;
                        type uint16 {
                            tailf:info "<1-300>;;seconds";
                            range "1..300";
                        }
                    }
                    leaf periodic-flooding {
                        tailf:info "Link Management periodic flooding interval";
                        tailf:cli-full-command;
                        type uint16 {
                            tailf:info "<0-3600>;;seconds";
                            range "0..3600";
                        }
                    }
                }
            }
            container logging {
                tailf:info "Trap logging configuration";
                container lsp {
                    tailf:info "LSP-specific traps logging configuration";
                    container path-errors {
                        tailf:info "Log LSP Path Error traps";
                        presence "Log LSP Path Error traps";
                        leaf access-list {
                            tailf:cli-drop-node-name;
                            type access-list-type;
                        }
                    }
                    container preemption {
                        tailf:info "Log LSP Preemption traps";
                        presence "Log LSP Preemption traps";
                        leaf access-list {
                            tailf:cli-drop-node-name;
                            type access-list-type;
                        }
                    }
                    container reservation-errors {
                        tailf:info "Log LSP Reservation Error traps";
                        presence "Log LSP Reservation Error traps";
                        leaf access-list {
                            tailf:cli-drop-node-name;
                            type access-list-type;
                        }
                    }
                    container setups {
                        tailf:info "Log LSP Establishment Traps";
                        presence "Log LSP Establishment Traps";
                        leaf access-list {
                            tailf:cli-drop-node-name;
                            type access-list-type;
                        }
                    }
                    container teardowns {
                        tailf:info "Log LSP Teardown Traps";
                        presence "Log LSP Teardown Traps";
                        leaf access-list {
                            tailf:cli-drop-node-name;
                            type access-list-type;
                        }
                    }
                }
                container tunnel {
                    tailf:info "Tunnel-specific traps logging configuration";
                    container lsp-selection {
                        tailf:info "Log Tunnel LSP Selection traps";
                        presence "Log Tunnel LSP Selection traps";
                        leaf access-list {
                            tailf:cli-drop-node-name;
                            type access-list-type;
                        }
                    }
                    container "path" {
                        tailf:info "Log Tunnel Path-related traps";
                        container change {
                            tailf:info "Log Tunnel Path change traps";
                            presence "Log Tunnel Path change traps";
                            leaf access-list {
                                tailf:cli-drop-node-name;
                                type access-list-type;
                            }
                        }
                    }
                }
            }
            container path-selection {
                tailf:info "Path Selection Configuration";

                leaf metric {
                    tailf:info "Metric Type Configuration";
                    tailf:cli-full-command;
                    type enumeration {
                        enum igp {
                            tailf:info "Use IGP metric";
                        }
                        enum te {
                            tailf:info "User TE metric";
                        }
                    }
                }
                container overload {
                    tailf:info "Overload Node Configuration";
                    container allow {
                        tailf:info "Allow overloaded nodes in CSPFs";
                        tailf:cli-sequence-commands;
                        leaf head {
                            tailf:info "Allow overloaded head node in TE CSPF";
                            tailf:cli-optional-in-sequence;
                            tailf:cli-reset-container;
                            type empty;
                        }
                        leaf middle {
                            tailf:info "Allow overloaded middle node in TE "
                                +"CSPF";
                            tailf:cli-optional-in-sequence;
                            tailf:cli-reset-container;
                            type empty;
                        }
                        leaf tail {
                            tailf:info "Allow overloaded middle node in TE "
                                +"CSPF";
                            tailf:cli-optional-in-sequence;
                            tailf:cli-reset-container;
                            type empty;
                        }
                    }
                }
            }
            container reoptimize {
                tailf:info "Reoptimization parameters";
                container events {
                    tailf:info "Reoptimization triggers";
                    leaf link-up {
                        tailf:info "Reoptimize tunnels on link up events";
                        type empty;
                    }
                }
                container timers {
                    tailf:info "Reoptimization timers";
                    container delay {
                        tailf:info "Delay reoptimization action";
                        leaf cleanup {
                            tailf:info "Delay cleanup of reoptimized LSP";
                            tailf:cli-full-command;
                            type uint8 {
                                range "0..60";
                                tailf:info "<0-60>;;seconds to delay "
                                    +"cleanup of replaced tunnel LSP";
                            }
                        }
                        leaf installation {
                            tailf:info "Delay replacement of current LSP "
                                +"by reoptimized LSP";
                            tailf:cli-full-command;
                            type uint16 {
                                range "0..3600";
                                tailf:info "<0-3600>;;seconds to delay "
                                    +"replacement of tunnel LSP";
                            }
                        }
                    }
                    leaf frequency {
                        tailf:info "Interval between reoptimization scans";
                        tailf:cli-full-command;
                        type uint32 {
                            tailf:info "<0-604800>;;seconds between "
                                +"reoptimizations (0 disables reoptimization)";
                            range "0..604800";
                        }
                    }
                }
            }
            container signalling {
                tailf:info "Traffic Engineering Signalling Parameters";
                container advertise {
                    tailf:info "Signalling advertisement parameters";
                    container implicit-null {
                        tailf:info "Use MPLS encoding for Implicit-Null "
                            +"Label in signalling messages";
                        presence  "Use MPLS encoding for Implicit-Null "
                            +"Label in signalling messages";
                        leaf nr {
                            tailf:cli-drop-node-name;
                            type uint8 {
                                range "1..99";
                                tailf:info "<1-99>;;Number of IP access-list "
                                    +"to determine applicable signalling peers";
                            }
                        }
                    }
                }
                container forwarding {
                    tailf:info "Control interaction of LSP signalling and "
                        +"LFIB maintenance";
                    leaf sync {
                        tailf:info "Program linecard LFIBs before signalling "
                            +"LSP label upstream";
                        type empty;
                    }
                }
                container restart {
                    tailf:info "Signalling restart parameters";
                    container neighbors {
                        tailf:info "Identify signalling restart capable neighbors";
                        presence "Identify signalling restart capable neighbors";
                        leaf nr {
                            tailf:cli-drop-node-name;
                            type uint8 {
                                range "1..99";
                                tailf:info "<1-99>;;Number of IP access-list "
                                    +"to determine applicable signalling peers";
                            }
                        }
                    }
                }
            }
            container topology {
                tailf:info "Topology Database Configuration";
                container holddown {
                    tailf:info "Topology Database hold down timers";

                    leaf sigerr {
                        tailf:info "Link hold down time for signalling errors";
                        type uint16 {
                            range "0..300";
                            tailf:info "<0-300>;;Hold down time in seconds";
                        }
                    }
                }
            }
            leaf tunnels {
                tailf:info "Traffic Engineering tunnels";
                tailf:cli-full-command;
                type empty;
            }
        }
    }

    typedef ldp-discovery-address-type {
        type union {
            type enumeration {
                enum interface {
                    tailf:code-name "ldp_interface";
                    tailf:info "Use interface address for LDP "
                        +"transport address";
                }
            }
            type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address to use for LDP "
                    +"transport address";
            }
        }
    }

    grouping ethernet-settings-grouping {
        // access-expression       Build a bridge boolean access expression
        // arp                     Set arp type (arpa, probe, snap) or timeout
        // backup                  Modify backup parameters
        // bandwidth               Set bandwidth informational parameter
        // bgp-policy              Apply policy propogated by bgp community string
        // bridge-group            Transparent bridging interface parameters
        // carrier-delay           Specify delay for interface transitions
        // cdp                     CDP interface subcommands
        // channel-group           Add this interface to an Etherchannel group
        // clns                    CLNS interface subcommands
        // cmns                    OSI CMNS
        // crypto                  Encryption/Decryption commands
        // custom-queue-list       Assign a custom queue list to an interface
        // dampening               Enable event dampening
        // default                 Set a command to its defaults
        // delay                   Specify interface throughput delay
        // description             Interface specific description
        // exit                    Exit from interface configuration mode
        // fair-queue              Enable Fair Queuing on an Interface
        // flow-sampler            Attach flow sampler to the interface
        // glbp                    Gateway Load Balancing Protocol interface commands
        // h323-gateway            Configure H323 Gateway
        // help                    Description of the interactive help system
        // hold-queue              Set hold queue depth
        // ip                      Interface Internet Protocol config commands
        // ipv6                    IPv6 interface subcommands
        // isis                    IS-IS commands
        // iso-igrp                ISO-IGRP interface subcommands
        // keepalive               Enable keepalive
        // llc2                    LLC2 Interface Subcommands
        // load-interval           Specify interval for load calculation for an
        //                         interface
        // logging                 Configure logging for interface
        // loopback                Configure internal loopback on an interface
        // mac-address             Manually set interface MAC address
        // max-reserved-bandwidth  Maximum Reservable Bandwidth on an Interface
        // mls                     mls sub/interface commands
        // mpls                    Configure MPLS interface parameters
        // mtu                     Set the interface Maximum Transmission Unit (MTU)
        // negotiation             Select autonegotiation mode
        // no                      Negate a command or set its defaults
        // ntp                     Configure NTP
        // priority-group          Assign a priority group to an interface
        // random-detect           Enable Weighted Random Early Detection (WRED) on an
        //                         Interface
        // rate-limit              Rate Limit
        // rmon                    Configure Remote Monitoring on an interface
        // shutdown                Shutdown the selected interface
        // snapshot                Configure snapshot support on the interface
        // snmp                    Modify SNMP interface parameters
        // standby                 HSRP interface configuration commands
        // timeout                 Define timeout values for this interface
        // traffic-shape           Enable Traffic Shaping on an Interface or
        //                         Sub-Interface
        // transmit-interface      Assign a transmit interface to a receive-only
        //                         interface
        // trunk-group             Configure interface to be in a trunk group
        // tx-ring-limit           Configure PA level transmit ring limit
        // vrrp                    VRRP Interface configuration commands

        container ip {
            tailf:info "Interface Internet Protocol config commands";
            // access-group        Specify access control for packets
            // accounting          Enable IP accounting on this interface

            // address             Set the IP address of an interface
            container address {
                tailf:info "Set the IP address of an interface";
                presence "Set the IP address of an interface";
                tailf:cli-incomplete-command;
                tailf:cli-show-no;

                choice address-choice {
                    case fixed-case {
                        container primary {
                            tailf:cli-drop-node-name;
                            tailf:cli-sequence-commands;
                            tailf:cli-compact-syntax;
                            tailf:cli-incomplete-command;
                            leaf address {
                                tailf:cli-incomplete-command;
                                tailf:cli-drop-node-name;
                                mandatory true;
                                type inet:ipv4-address {
                                    tailf:info "A.B.C.D;;IP address";
                                }
                            }
                            leaf mask {
                                tailf:cli-drop-node-name;
                                mandatory true;
                                type inet:ipv4-address {
                                    tailf:info "A.B.C.D;;IP subnet mask";
                                }
                            }
                        }
                        list secondary {
                            key "address";
                            tailf:cli-incomplete-command;
                            tailf:cli-sequence-commands;
                            tailf:cli-compact-syntax;
                            tailf:cli-drop-node-name;
                            tailf:cli-suppress-mode;

                            leaf address {
                                type inet:ipv4-address {
                                    tailf:info "A.B.C.D;;IP address";
                                }
                            }
                            leaf mask {
                                tailf:cli-drop-node-name;
                                tailf:cli-incomplete-command;
                                mandatory true;
                                type inet:ipv4-address {
                                    tailf:info "A.B.C.D;;IP subnet mask";
                                }
                            }
                            leaf secondary {
                                tailf:info "Make this IP address a secondary address";
                                type empty;
                            }
                        }
                    }
                    case dhcp-case {
                        container dhcp {
                            tailf:info "IP Address negotiated via DHCP";
                            presence  "IP Address negotiated via DHCP";
                            tailf:cli-sequence-commands;
                            container client-id {
                                tailf:cli-flatten-container;
                                tailf:info "Specify client-id to use";
                                tailf:cli-optional-in-sequence;
                                choice client-id-choice {
                                    leaf FastEthernet {
                                        tailf:info "FastEthernet IEEE 802.3";
                                        type leafref {
                                            path "/c:interface/FastEthernet/name";
                                        }
                                    }
                                    // leaf GigabitEthernet {
                                    //     tailf:info "GigabitEthernet IEEE 802.3z";
                                    //     type leafref {
                                    //         path "/c:interface/GigabitEthernet/name";
                                    //     }
                                    // }
                                    // leaf Port-channel {
                                    //     tailf:info "Ethernet Channel of interfaces";
                                    //     type leafref {
                                    //         path "/c:interface/Port-channel/name";
                                    //     }
                                    // }
                                    // leaf Vlan {
                                    //     tailf:info "Catalyst Vlans";
                                    //     type leafref {
                                    //         path "/c:interface/vlan/name";
                                    //     }
                                    // }
                                }
                            }
                            leaf hostname {
                                tailf:info "Specify value for hostname option";
                                type string {
                                    tailf:info "WORD;;hostname string";
                                }
                            }
                        }
                    }
                }
            }

            // authentication      authentication subcommands
            // bandwidth-percent   Set EIGRP bandwidth limit
            // bgp                 BGP interface commands
            // broadcast-address   Set the broadcast address of an interface
            // cef                 Cisco Express Forwarding interface commands
            // cgmp                Enable/disable CGMP
            // dhcp                Configure DHCP parameters for this interface
            // directed-broadcast  Enable forwarding of directed broadcasts
            // dvmrp               DVMRP interface commands
            // flow                NetFlow related commands
            // header-compression  IPHC options
            // hello-interval      Configures IP-EIGRP hello interval
            // helper-address      Specify a destination address for UDP broadcasts
            // hold-time           Configures IP-EIGRP hold time
            // igmp                IGMP interface commands
            // information-reply   Enable sending ICMP Information Reply messages
            // irdp                ICMP Router Discovery Protocol
            // load-sharing        Style of load sharing
            // local-proxy-arp     Enable local-proxy ARP
            // mask-reply          Enable sending ICMP Mask Reply messages
            // mrm                 Configure IP Multicast Routing Monitor tester
            // mroute-cache        Enable switching cache for incoming multicast packets
            // mtu                 Set IP Maximum Transmission Unit
            // multicast           IP multicast interface commands
            // nbar                Network-Based Application Recognition
            // next-hop-self       Configures IP-EIGRP next-hop-self
            // nhrp                NHRP interface subcommands
            // ospf                OSPF interface commands
            // pim                 PIM interface commands
            // policy              Enable policy routing
            // probe               Enable HP Probe support
            // proxy-arp           Enable proxy ARP
            // rarp-server         Enable RARP server for static arp entries
            // redirects           Enable sending ICMP Redirect messages
            // rgmp                Enable/disable RGMP
            // rip                 Router Information Protocol
            // route-cache         Enable fast-switching cache for outgoing packets
            // router              IP router interface commands
            // rsvp                RSVP interface commands
            // rtp                 RTP parameters
            // sap                 Session Advertisement Protocol interface commands
            // security            DDN IP Security Option
            // split-horizon       Perform split horizon
            // summary-address     Perform address summarization
            // tcp                 TCP header compression
            // traffic-export      Configure this interface for exporting ip traffic
            // unnumbered          Enable IP processing without an explicit address
            // unreachables        Enable sending ICMP Unreachable messages
            // urd                 Configure URL Rendezvousing
            // verify              Enable per packet validation
            // vrf                 VPN Routing/Forwarding parameters on the interface
            // wccp                WCCP interface commands

        }

        container mpls {
            tailf:info "Configure MPLS interface parameters";

            container accounting {
                tailf:info "Enable MPLS accounting on this interface";
                container experimental {
                    tailf:info "Count packets by MPLS experimental value on "
                        +"this interface";
                    leaf input {
                        tailf:info "received packets";
                        type empty;
                    }
                    leaf output {
                        tailf:info "transmitted packets";
                        type empty;
                    }
                }
            }
            container bgp {
                tailf:info "MPLS BGP";
                leaf forwarding {
                    tailf:info "Configure MPLS forwarding for directly "
                        +"connected BGP peers";
                    type empty;
                }
            }
            leaf ip {
                tailf:info "Configure dynamic MPLS forwarding for IP";
                tailf:cli-full-command;
                type empty;
            }
            container label {
                tailf:info "Label properties";
                leaf protocol {
                    tailf:info "Configure label/tag distribution "
                        +"protocol (LDP/TDP)";
                    type enumeration {
                        enum both {
                            tailf:info "Use LDP or TDP (Adapt to peer "
                                +"on multiaccess interface)";
                        }
                        enum ldp {
                            tailf:code-name "lab_ldp";
                            tailf:info "Use LDP (default)";
                        }
                        enum tdp {
                            tailf:code-name "lab_tdp";
                            tailf:info "Use TDP";
                        }
                    }
                }
            }
            container ldp {
                tailf:info "Configure Label Distribution Protocol "
                    +"(LDP) parameters";
                container discovery {
                    tailf:info "Configure interface LDP Discovery parameters";
                    leaf transport-address {
                        tailf:info "Specify interface LDP transport address";
                        type ldp-discovery-address-type;
                    }
                }
            }
            leaf mtu {
                tailf:info "Set MPLS Maximum Transmission Unit";
                tailf:cli-full-command;
                type union {
                    type uint16 {
                        range "1501..1524";
                        tailf:info "<1501-1524>;;MTU (baby giants bytes)";
                    }
                    type uint16 {
                        range "64..1500";
                        tailf:info "<64-1500>;;MTU (bytes)";
                    }
                }
            }
            container traffic-eng {
                tailf:info "Configure Traffic Engineering parameters";
                leaf administrative-weight {
                    tailf:info "Set the administrative weight for the interface";
                    tailf:cli-full-command;
                    type uint32 {
                        range "0..4294967295";
                        tailf:info "<0-4294967295>;;Weight";
                    }
                }
                leaf attribute-flags {
                    tailf:info "Set user-defined interface "
                        +"attibute flags";
                    tailf:cli-full-command;
                    type tailf:hex-list {
                        tailf:info "<0x0-0xFFFFFFFF>;;Attribute flags";
                    }
                }
                container flooding {
                    tailf:info "Set flooding parameters";
                    container thresholds {
                        tailf:info "Set flooding thresholds";
                        leaf-list down {
                            tailf:info "Set the thresholds for decreased "
                                +"resource availability";
                            tailf:cli-flat-list-syntax;
                            type uint8 {
                                range "0..100";
                                tailf:info "<0-100>;;decreased bandwidth usage (percent)";
                            }
                        }
                        leaf-list up {
                            tailf:info "Set the thresholds for increased "
                                +"resource availability";
                            tailf:cli-flat-list-syntax;
                            type uint8 {
                                range "0..100";
                                tailf:info "<0-100>;;increased bandwidth usage "
                                    +"(percent)";
                            }
                        }
                    }
                }
                leaf tunnels {
                    tailf:info "enable MPLS Traffic Engineering tunnels";
                    tailf:cli-full-command;
                    type empty;
                }
            }

        }
        leaf shutdown {
            tailf:cli-full-command;
            tailf:info "Administratively shut down this neighbor";
            type boolean;
            default "true";
            tailf:cli-boolean-no;
            tailf:cli-trim-default;
        }
        leaf mtu {
            tailf:info "Set the interface Maximum Transmission "
                +"Unit (MTU)";
            tailf:cli-full-command;
            type uint16 {
                range "64..18000";
                tailf:info "<64-18000>;;MTU size in bytes";
            }
        }

        // service-policy          Configure QoS Service Policy
        container service-policy {
            tailf:info "Configure QoS Service Policy";

            leaf history {
                tailf:cli-full-command;
                tailf:info "Keep history of QoS metrics";
                type empty;
            }

            leaf input {
                tailf:cli-full-command;
                tailf:info "Assign policy-map to the input of an interface";
                type string {
                    tailf:info "WORD;;policy-map name";
                }
            }

            leaf output {
                tailf:cli-full-command;
                tailf:info "Assign policy-map to the output of an interface";
                type string {
                    tailf:info "WORD;;policy-map name";
                }
            }
        }

        // xconnect                Xconnect commands
        container xconnect {
            tailf:info "Xconnect commands";
            tailf:cli-sequence-commands;
            tailf:cli-compact-syntax;

            leaf address {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP address of peer";
                }
            }

            leaf vcid {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint32 {
                    tailf:info "<1-4294967295>;;Enter VC ID value";
                    range "1..4294967295";
                }
            }

            leaf encapsulation {
                tailf:info "Data encapsulation method";
                tailf:cli-optional-in-sequence;
                type enumeration {
                    enum mpls {
                        tailf:code-name "encap_mpls";
                        tailf:info "Use MPLS encapsulation";
                    }
                    enum l2tpv3 {
                        tailf:info "Use L2TPv3 encapsulation";
                    }
                }
            }
            leaf manual {
                tailf:info "Manually configure L2TP session parameters";
                tailf:cli-optional-in-sequence;
                when "../encapsulation = 'l2tpv3'";
                type empty;
            }
            leaf sequence {
                tailf:info "Configure sequencing options for xconnect";
                tailf:cli-full-command;
                tailf:cli-optional-in-sequence;
                when "../encapsulation = 'l2tpv3'";
                type enumeration {
                    enum both {
                        tailf:info "Transmit and receive sequence numbers";
                    }
                    enum receive {
                        tailf:info "Receive sequence numbers";
                    }
                    enum transmit {
                        tailf:info "Transmit sequence numbers";
                    }
                }
            }
            leaf pw-class {
                tailf:info "Pseudowire-class to use for encapsulation and protocol "
                    +"configuration";
                type string {
                    tailf:info "WORD;;Pseudowire-class name";
                }
            }
        }
    }

    container interface {
        tailf:info "Configure interfaces";

        list FastEthernet {
            tailf:info "FastEthernet IEEE 802.3";
            tailf:cli-allow-join-with-key {
                tailf:cli-display-joined;
            }
            tailf:cli-mode-name "config-if";

            key "name";

            leaf name {
                type string {
                    // pattern "([0-9])+/([0-9])+(/([0-9])+)?";
                    tailf:info "<0-66>/<0-128>;;FastEthernet interface number";
                }
            }

            uses ethernet-settings-grouping;
        }
    }

    list route-map {
      tailf:info "Route map tag";
      tailf:cli-mode-name "route-map";
      tailf:cli-compact-syntax;
      tailf:cli-full-command;

      key "name sequence" ;
      leaf name {
        tailf:info "WORD;;Route map tag";
        type string;
      }
      leaf sequence {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-65535>;;Sequence to insert to/delete from existing route-map entry";
          range "0..65535";
        }
      }
      leaf operation {
        tailf:cli-drop-node-name;

        tailf:cli-prefix-key {
          tailf:cli-before-key 2;
        }
        type enumeration {
          enum deny {
            tailf:code-name "op_deny";
            tailf:info "Route map denies set operations";
          }
          enum permit {
            tailf:code-name "op_internet";
            tailf:info "Route map permits set operations";
          }
        }
        default permit;
      }


      container set {
        tailf:info "Set values in destination routing protocol";
        container community {
          tailf:info "BGP community attribute";
          choice community-choice {
            case community-numberi-case {
              leaf community-number {
                tailf:cli-drop-node-name;
                  type uint32 {
                  tailf:info "<1-4294967295>;;community number";
                  range "1..4294967295";
                }
              }

              leaf community-number-alt-format {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "aa:nn;;community number in aa:nn format";
                  pattern "(\d+:\d+)";
                }
              }
            }
            case well-known-community-case {
              leaf well-known-communities {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum internet {
                    tailf:info "Internet (well-known community)";
                  }
                  enum local-AS {
                    tailf:info "Do not send outside local AS (well-known community)";
                  }
                  enum no-advertise {
                    tailf:info "Do not advertise to any peer (well-known community)";
                  }
                  enum no-export {
                    tailf:info "Do not export to next AS (well-known community)";
                  }
                  enum none {
                    tailf:info "No community attribute";
                  }
                }
              }
            }
          }
          leaf additive {
            tailf:info "Add to the existing community";
            type empty;
          }
        }
        // end community
        container comm-list {
          tailf:info "set BGP community list (for deletion)";
          tailf:cli-sequence-commands;
          choice comm-list-choice {
            leaf comm-list-standard {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<1-99>;;Community-list number (standard)";
                range "1..99";
              }
            }
            leaf comm-list-expanded {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<100-500>;;Community-list number (expanded)";
                range "100..500";
              }
            }
            leaf comm-list-name {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type string {
                tailf:info "WORD;;Community-list name";
              }
            }
          }
          leaf delete {
            tailf:cli-full-command;
            tailf:info "Delete matching communities";
            type empty;
          }
        }
        // end comm-list
        container as-path {
          tailf:info "Prepend string for a BGP AS-path attribute";
          container prepend {
            tailf:info "Prepend to the as-path";
            container as-container {
              tailf:cli-drop-node-name;
              leaf as-number {
                tailf:info "<1-65535>;;AS number";
                tailf:cli-drop-node-name;
                tailf:cli-multi-value;
                type string {
                  tailf:info "<1-65535>;;AS number";
                }
              }
            }
            container last-as-cont {
              tailf:cli-drop-node-name;
              leaf last-as {
                type uint16 {
                  tailf:info "<1..10>;;number of last-AS prepends";
                  range "1..10";
                }
              }
            }
          }
          container tag {
            tailf:info "Set the tag as an AS-path attribute";
            tailf:cli-full-command;
            presence "tag";
          }
        }
        // end as-path
       /* container metric {
          tailf:info "Metric value for destination routing protocol";
          choice metric-choice {
            leaf add-sub-metric {
              type string {
                tailf:info "+/-<metric>;;Add or subtract metric";
                // pattern needed
              }
            }
            leaf metric {
              type uint32 {
                tailf:info "<0-4294967295>;;Metric value or Bandwidth in Kbits per second";
              }
            }
          }
        }*/
        // end metric
      }
      // end set
      container match {
        tailf:info "Match values from routing table";
        container community {
          tailf:info "Match BGP community list";
          leaf-list name {
            tailf:info "Named Access List";
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            type string {
              tailf:info "<1-99>       Community-list number (standard)
  <100-500>       Community-list number (expanded)
  WORD            Community-list name
  exact-match     Do exact matching of communities
";
            }
          }
        }
      }
      // end match
    }
}
